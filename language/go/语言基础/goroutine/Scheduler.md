## 一、调度器模型概述
### 1. M:N 调度
- **M**：表示 goroutine 的数量，通常非常多（可以轻松创建数十万甚至更多）。
- **N**：表示操作系统线程的数量，通常与 CPU 核心数相关。
- Go 调度器在运行时将多个 goroutine 动态分配到少量的操作系统线程上执行，而不是为每个 goroutine 创建一个独立的 OS 线程。这种方式避免了操作系统线程的高开销（如内存占用和上下文切换成本）。

### 2. 核心组件
Go 调度器的实现依赖三个主要抽象概念：
- **G（Goroutine）**：表示一个 goroutine，包含执行的函数、栈和状态等信息。
- **M（Machine）**：表示一个操作系统线程，由内核管理，直接与硬件交互。
- **P（Processor）**：表示逻辑处理器，是调度器的调度单元，负责将 G 绑定到 M 上运行。P 的数量通常由 `GOMAXPROCS` 决定（默认等于 CPU 核心数）。

---

## 二、调度器的工作原理
### 1. G、M、P 的关系
- **P 是调度核心**：每个 P 维护一个本地运行队列（run queue），里面存储等待执行的 goroutine（G）。P 会从队列中取出 G 并将其绑定到 M 上运行。
- **M 是执行者**：M 是真正的操作系统线程，执行 P 分配的 G。M 和 P 的数量可以不同，通常 M 的数量略多于 P，以处理阻塞情况。
- **G 是任务**：G 是调度器管理的任务单元，创建时会被放入某个 P 的运行队列。

### 2. 全局和本地队列
- **本地运行队列**：每个 P 都有自己的本地队列，存储待执行的 G。
- **全局运行队列**：当某个 P 的本地队列满了，新创建的 G 会被放入全局队列。其他 P 可以从全局队列“窃取”任务（work-stealing）。
- **工作窃取（Work-Stealing）**：如果某个 P 的本地队列为空，它会尝试从其他 P 的队列或全局队列中窃取 G，以实现负载均衡。

### 3. 调度过程
1. **创建 goroutine**：调用 `go func()` 时，创建一个 G，放入当前 P 的本地队列。
2. **分配执行**：P 从本地队列取出一个 G，绑定到某个 M 上运行。
3. **上下文切换**：如果 G 执行中被阻塞（如 I/O 操作）或时间片用尽，调度器会暂停当前 G，保存其状态，并切换到另一个 G。
4. **线程管理**：如果所有 M 都在忙碌且有待执行的 G，调度器会创建新的 M；如果 M 长时间空闲，则可能被销毁。

---

## 三、调度器的关键特性
### 1. 抢占式调度
- **早期版本（<1.14）**：Go 调度器是非抢占式的，goroutine 需要主动让出控制权（如调用函数或 I/O 操作时）。
- **现代版本（>=1.14）**：引入了抢占式调度。如果一个 goroutine 长时间占用线程（如死循环），调度器会在安全点（如函数调用边界）插入抢占信号，暂停它并调度其他 G。

### 2. GOMAXPROCS
- `GOMAXPROCS` 是运行时的一个参数，默认等于 CPU 核心数，表示最多有多少个 P 可以同时运行。
- 可以通过 `runtime.GOMAXPROCS(n)` 修改，但通常不需要调整。
- 示例：在一台 4 核机器上，默认 `GOMAXPROCS=4`，最多有 4 个 P 并行执行 goroutine。

### 3. 系统调用处理
- 当 goroutine 执行系统调用（如文件 I/O、网络请求）并阻塞时：
  - 当前 M 被阻塞，P 会脱离这个 M，寻找或创建一个新的 M 来继续执行其他 G。
  - 系统调用完成后，原 M 归还给线程池，等待下次使用。

### 4. 网络 I/O 优化
- Go 的网络库（如 `net` 包）集成了 **netpoller**，将网络 I/O 操作与调度器结合。
- 当 goroutine 等待网络 I/O 时，它会被暂停，P 和 M 继续处理其他任务，而不是阻塞整个线程。

---

## 四、调度器的工作流程示例
假设有一台双核机器（`GOMAXPROCS=2`）：
1. 创建 3 个 goroutine：G1、G2、G3。
2. 调度器初始化 2 个 P（P1、P2）和若干 M。
3. G1 和 G2 分别放入 P1 和 P2 的本地队列，G3 放入全局队列。
4. P1 将 G1 绑定到 M1 执行，P2 将 G2 绑定到 M2 执行。
5. 如果 G1 阻塞（如 I/O），P1 脱离 M1，绑定到新的 M3，继续执行其他 G（如从全局队列取 G3）。
6. P2 如果空闲，会从全局队列或 P1 的队列窃取任务。

---

## 五、调度器的优势与局限
### 1. 优势
- **轻量**：goroutine 比 OS 线程占用资源少，创建和销毁成本低。
- **高效**：M:N 模型和 work-stealing 机制充分利用 CPU 资源。
- **简单**：开发者无需手动管理线程，只需使用 `go` 和 channel。

### 2. 局限
- **依赖运行时**：调度器是 Go 运行时的一部分，无法直接控制底层线程行为。
- **抢占不完全**：尽管 1.14 后支持抢占，但仍需在安全点触发，可能无法处理极端情况（如无函数调用的死循环）。

---

## 六、代码示例
以下是一个展示调度器行为的简单例子：
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func printNumbers(id int) {
    for i := 0; i < 5; i++ {
        fmt.Printf("Goroutine %d: %d\n", id, i)
        runtime.Gosched() // 主动让出控制权（可选）
    }
}

func main() {
    runtime.GOMAXPROCS(2) // 设置 2 个逻辑处理器
    for i := 1; i <= 3; i++ {
        go printNumbers(i)
    }
    time.Sleep(1 * time.Second) // 等待 goroutine 执行
}
```
- **输出**：3 个 goroutine 在 2 个 P 上并发运行，顺序不确定。

---

## 七、总结
Go 的调度器通过 G、M、P 三者协作，实现了一个高效的 M:N 调度模型。它将并发管理的复杂性隐藏在运行时中，让开发者专注于业务逻辑。理解调度器的工作原理有助于优化并发程序的性能，尤其是在高负载场景下。
