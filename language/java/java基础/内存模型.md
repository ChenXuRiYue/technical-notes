# Java 内存模型

## 概述

Java 内存模型（Java Memory Model, JMM）是基于 JVM（Java 虚拟机）的规范，定义了 Java 程序中线程与内存之间的交互规则。它具有以下特性：
- **线程隔离**：每个线程有独立的内存空间（如栈），但共享堆内存。
- **内存可见性**：多线程环境下，线程对共享变量的修改需通过 JMM 保证一致性。
- **运行时分配**：JVM 在运行时动态管理内存，分为线程私有和共享区域。

JMM 的核心目标是屏蔽底层硬件差异，提供一致的内存访问模型。

## 内存区域划分以及详解

1. **虚拟机栈（VM Stack）**
   - **作用**：线程私有，每调用一个方法时创建一个栈帧，存储局部变量表、操作数栈、方法返回地址等。
   - **特点**：方法执行时入栈，执行完毕出栈；栈深度不足抛 `StackOverflowError`。
   - **生命周期**：随线程创建而分配，随线程结束而销毁。

2. **本地方法栈（Native Method Stack）**
   - **作用**：线程私有，类似虚拟机栈，但为本地方法（Native Method，通常由 C/C++ 实现）服务。
   - **特点**：支持 JVM 调用底层操作系统功能，具体实现依赖 JVM 和平台。
   - **异常**：栈溢出时抛 `StackOverflowError`。

3. **堆（Heap）**
   - **作用**：线程共享，存储所有对象实例和数组，是 JVM 内存管理的核心区域。
   - **特点**：由垃圾回收器（GC）管理，分新生代（Young Generation）和老年代（Old Generation）。
   - **异常**：内存不足时抛 `OutOfMemoryError`。
   - **注意**：对象引用存储在栈中，对象内容存储在堆中。

4. **元空间（Metaspace）**
   - **作用**：线程共享，取代 JDK 1.7 及之前的永久代（PermGen），存储类元数据（如类信息、方法信息、常量池）。
   - **特点**：使用本地内存（Native Memory），默认无大小限制，受系统内存约束。
   - **异常**：元数据过多时抛 `OutOfMemoryError: Metaspace`。
   - **变化**：从 JDK 1.8 开始引入，提升 GC 效率和内存管理灵活性。

- **程序计数器（Program Counter Register）**（未列在你的框架中，但很重要）：
  - 线程私有，记录当前线程执行的字节码指令地址，用于控制指令流。
  - 无内存溢出风险，唯一没有 `OutOfMemoryError` 的区域。

## Demo

### 1. 对象创建、传递引用

```java
X a = new X();
X b = a;
```

`X a = new X()` : 在栈中创建 引用变量 a。 堆中创建一个X类型的对象实例 。 a 引用指向了 对象实例
`X b = a`：在栈中创建引用变量b。b 复制了 a 引用对象的内容。

解译

```java
堆内存 (Heap):
  地址 0x1234: [X 对象实例]

栈内存 (Stack):
  a -> 0x1234
  b -> 0x1234
```

