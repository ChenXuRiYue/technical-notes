# 2025-7-3

目标稳定前10%：
分数突破 2400

**双周赛**

[双周赛161](https://leetcode.cn/contest/biweekly-contest-161/)
[周赛459](https://leetcode.cn/contest/weekly-contest-459/)

## 复盘

周赛1：两题 332/1154       35%
周赛2：三题 340/1638       20%

## 本场可规避错误

1. 数据范围：

    且不说是否算的准，根本没有算的意识。以后集成一个模版，无脑开 l l 就对了。

2. 过度依赖感觉：
    [提交列表 10 发罚时](https://leetcode.cn/contest/weekly-contest-459/problems/count-number-of-trapezoids-i/description/)： 对于简单的数数题，很容易的就可以感受解集。过度依赖结论，不感受不论证，导致大量的罚时。

3. 语法生疏+理解漏洞：
    本周比赛使用了 \_\_builtin\_popcount(usigned int) 计算数字二进制格式中 1 的个数。然而该数字范围为 $10^{14}$​。我竟然从来不知道 \_\_builtin\_popcount(usigned int) 的范围是 usigned int！

  \_\_builtin\_popcountll  用于 64 位数字的二进制串中 1 比特 计算。



## 补题

### [3621. 位计数深度为 K 的整数数目 I](https://leetcode.cn/problems/number-of-integers-with-popcount-depth-equal-to-k-i/)

<img src="https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250722231037598.png" alt="image-20250722231037598" style="zoom: 50%;" />

观察发现，一个数字的深度值域是非常小的。可以将所有数字收缩到 二进制比特串中 有多少个数字1 中。这个可以使用 数位 dp 或者简单的枚举 + 组合计数实现。

```c++
/*
 * @lc app=leetcode.cn id=3621 lang=cpp
 *
 * [3621] 位计数深度为 K 的整数数目 I
 */

// @lc code=start
#include<iostream>
#include<array>
#include<vector>
using namespace std;
using ll = long long;
int init_flag;
const int N_c = 60;
const int mod = 1E18 + 7;
ll c[N_c][N_c];
void C_init() {
    c[0][0] = 1;
    for (int i = 1; i < N_c; ++i) {
        c[i][0] = c[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) ;
        }
    }
}


void init() {
  if(init_flag) return;
  init_flag = true;
  C_init();
}

class Solution {
public:
    long long popcountDepth(long long n, int k) {
        if(k == 0) {
            return 1;
        }
        init();
        ll cunt[68] = {}; 
        vector<int> bitn;
        while(n) {
            bitn.push_back(n % 2);
            n /= 2;
        }
        reverse(bitn.begin(), bitn.end());
        int pre1 = 0;
        for(int i = 0; i < bitn.size(); i++) {
            if(bitn[i]) {
                int remain = (int)bitn.size() - (i + 1);
                cout << "remain " << remain << "\n";
                for(int j = 0; j <= remain; j++) {
                    cunt[pre1 + j] += c[remain][j];
                }
                pre1++;
            }
        }
        cunt[pre1]++;
        cunt[1]--;
        long long ans = 0;
        for(int i = 60; i >= 1; i--) {
            int sum = 0;
            int ti = i;
            while(ti != 1) {
                ti = __builtin_popcount(ti); 
                sum++;
            }
            if(sum + 1 == k) {
                cout << i << "\n";
                ans += cunt[i];
            }
        }

        return ans;
    }
};
// @lc code=end
```

### [统计梯形数目 II](https://leetcode.cn/contest/weekly-contest-459/problems/count-number-of-trapezoids-ii/description/)





