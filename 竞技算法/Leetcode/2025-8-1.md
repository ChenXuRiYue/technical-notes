# 🏁 2025-8-1

🏆 排名：162双周赛（475 / 1211）、461（161/1633）

🎈 过题数：3，4

🔖 算法标签：莫队

# 💭 复盘

162双周赛打的一坨。第三道题选了麻烦的解法，并且边界处理出了很多问题。这次补体第四题算法是莫队罚坐算法。

# 🪾补题

## [Q3. 最早完成陆地和水上游乐设施的时间 II](https://leetcode.cn/contest/biweekly-contest-162/problems/earliest-finish-time-for-land-and-water-rides-ii/)

![image-20250804135933293](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250804135933293.png)

**补题类型：** 码风优化，更优思路。

原思路：假设从陆地选出设施为 a，从水上游乐设施选出为b。显然最优秀解中至少 a，或 b 是满足条件立刻启动的。因此考虑枚举立刻启动的游乐设施算出对应的最优方案，最后综合取最小值则为最优方案。

考虑 枚举 a， 则可能情况为 $ba、ab_0、ab$ 三种情形。其中 $b$ 表示满足条件即刻开始游玩的设施。 $b_0$ 则与之相反，满足条件过一段时间后才开始游玩。

**定义**：

1. $f(x)$ 表示游乐设施 $x$ 的最早开始时间
2. $g(x)$ 表示游乐设施 $x$ 的最早结束时间
3. $l(x)$ 表示游乐设施 $x$ 的持续时间

对于 $ba$，总是满足 $ba = f(a)$ 若存在  $g(b) <= f(a)$
对于 $ab_0$，最优解为 $g(a) + min\{l(x),f(x) <= g(a)\}$
对于 $ab$，最优解为 $min\{g(x)/f(x) \ge g(a)\}$

反过来再枚举一遍 $b$

于是用最蠢的方法，硬编码了两段枚举，因为修改不恰，多贡献了几个罚时。

```c++
class Solution {
public:
    int earliestFinishTime(vector<int>& ls, vector<int>& ld, vector<int>& ws, vector<int>& wd) {
        int n = ls.size(), m = ws.size();
        vector<array<int, 2>> a, b;
        for(int i = 0; i < n; i++) {
            a.push_back({ls[i], ls[i] + ld[i]});
        }
        for(int i = 0; i < m; i++) {
            b.push_back({ws[i], ws[i] + wd[i]});
        }
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        // a
        const int inf = 1E9 + 7;
        vector<int> suf(m + 1), pre(m + 1);
        suf[m] = inf;
        for(int i = m - 1; i >= 0; i--) {
            suf[i] = min(suf[i + 1], b[i][1]);
        }
        for(int i = 0; i < m; i++) {
            if(i == 0) {
                pre[i] = b[i][1] - b[i][0];
            }else {
                pre[i] = min(pre[i - 1], b[i][1] - b[i][0]);
            }
        }
        // for(int i = 0; i < m; i++) {
        //     cout << b[i][0] << " " << b[i][1] << "\n";
        //     cout << pre[i] << " \n";
        // }
        
        int ans = inf;
        for(int i = 0 ; i < n; i++) {
            //x a
            if(a[i][0] >= b[0][1]) {
                ans = min(ans, a[i][1]);
            }
            int id = upper_bound(b.begin(), b.end(), array<int, 2>{a[i][1], 0}) - b.begin();
            // cout << "==== \n";
            // cout << "id " << id << " ans" << ans <<" a[i][0] " << a[i][0] << " a[i][1]" << a[i][1] <<  "\n";
            if(id == m) {
                ans = min(ans, a[i][1] + pre[m - 1]);
            } else if(id == 0) {
                ans = min(ans, suf[id]);
            } else {
                ans = min({ans, a[i][1] + pre[id - 1], suf[id]});
            }
        }

        suf = vector<int> (n + 1);
        pre = vector<int>(n + 1);
        suf[n] = inf;
        for(int i = n - 1; i >= 0; i--) {
            suf[i] = min(suf[i + 1], a[i][1]);
        }
        for(int i = 0; i < n; i++) {
            if(i == 0) {
                pre[i] = a[i][1] - a[i][0];
            }else {
                pre[i] = min(pre[i - 1], a[i][1] - a[i][0]);
            }
        }
        
        for(int i = 0; i < m; i++) {
            //x a
            if(b[i][0] >= a[0][1]) {
                ans = min(ans, b[i][1]);
            }
            int id = upper_bound(a.begin(), a.end(), array<int, 2>{b[i][1], 0}) - a.begin();
            if(id == n) {
                ans = min(ans, b[i][1] + pre[n - 1]);
            } else if(id == 0) {
                ans = min(ans, suf[id]);
            } else {
                ans = min({ans, b[i][1] + pre[id - 1], suf[id]});
            }
        }
        return ans;
        
    }
};
```

**优化**

不难发现它们是对称的，完全可以将上述过程抽象为一个函数，最后调整入参即可

**优化后的代码**

```c++
class Solution {
public:
    int earliestFinishTime(vector<int>& ls, vector<int>& ld, vector<int>& ws, vector<int>& wd) {
        return min(solve(ls, ld, ws, wd), solve(ws, wd, ls, ld));
    }
    int solve(vector<int>& ls, vector<int>& ld, vector<int>& ws, vector<int>& wd) {
        int n = ls.size(), m = ws.size();
        vector<array<int, 2>> a, b;
        for(int i = 0; i < n; i++) {
            a.push_back({ls[i], ls[i] + ld[i]});
        }
        for(int i = 0; i < m; i++) {
            b.push_back({ws[i], ws[i] + wd[i]});
        }
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        // a
        const int inf = 1E9 + 7;
        vector<int> suf(m + 1), pre(m + 1);
        suf[m] = inf;
        for(int i = m - 1; i >= 0; i--) {
            suf[i] = min(suf[i + 1], b[i][1]);
        }
        for(int i = 0; i < m; i++) {
            if(i == 0) {
                pre[i] = b[i][1] - b[i][0];
            }else {
                pre[i] = min(pre[i - 1], b[i][1] - b[i][0]);
            }
        }
        
        int ans = inf;
        for(int i = 0 ; i < n; i++) {
            //x a
            if(a[i][0] >= b[0][1]) {
                ans = min(ans, a[i][1]);
            }
            int id = upper_bound(b.begin(), b.end(), array<int, 2>{a[i][1], 0}) - b.begin();
            if(id == m) {
                ans = min(ans, a[i][1] + pre[m - 1]);
            } else if(id == 0) {
                ans = min(ans, suf[id]);
            } else {
                ans = min({ans, a[i][1] + pre[id - 1], suf[id]});
            }
        }
        return ans;
    }
};
```

## [Q4. 查询超过阈值频率最高元素](https://leetcode.cn/contest/biweekly-contest-162/problems/threshold-majority-queries/)

<img src="https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250804141516123.png" alt="image-20250804141516123" style="zoom:50%;" />

${\large {\color[RGB]{250, 157, 30}思路分析}} $

**基本思路：** 这种问题显然是维护一个数据结构，而维护线段树的一个痛点是众数值域过大，难以维护信息。即使对数字进行离散化，区间的修改，合并等操作复杂度都将会非常大。

如果是暴力的维护处理，复杂度显然是 $O(n^2)$。在这个暴力的过程中，发现一个数字总是被多个区间询问的，怎么设计一个算法最大限度的防止一个区间被重复处理呢？

引出 **莫队**，具体看 **learning** 教程。

**删除元素时信息维护**

1. 根据数量开 $set$ 数组 $set[N]$ 维护。总复杂度：$O(n\sqrt q log_n)$
2. 根据数量开 $bitset$ 数组 $bitset[N]$。总复杂度：$O(\frac {n\sqrt q )\times 10000}{64})$

**避免删除元素**

可以使用回滚莫队



${\large {\color[RGB]{250, 157, 30}Code-1}} $

使用 $set$ 维护即可

```C++
struct message {
  // 维护基本信息
  vector<set<int>> cunt;
  vector<int> mp;
  int miNum, mxCunt;
  // 初始化
  message(int n) {
    cunt.resize(n + 1);
    mp.resize(n + 1);
    miNum = 1E9 + 7, mxCunt = 0;
  }
  // 增加元素
  void add(int x) {
    // 增加逻辑
    int x_cunt = mp[x];
    mp[x] = x_cunt + 1;
    cunt[x_cunt].erase(x);
    cunt[++x_cunt].insert(x);
    if(x_cunt > mxCunt) {
        mxCunt = x_cunt;
        miNum = x;
    } else if(x_cunt == mxCunt) {
        miNum = min(miNum, x);
    }
  }

  // 删除元素
  void del(int x) {
    // 删除逻辑
    int x_cunt = mp[x];
    mp[x] = x_cunt - 1;
    cunt[x_cunt].erase(x);
    cunt[--x_cunt].insert(x);

    // 原来不是最高
    if(x_cunt + 1 != mxCunt) {
        return;
    } 
    // 原来是最高
    // 1. 还有元素
    if(cunt[x_cunt + 1].size()) {
        miNum = *cunt[x_cunt + 1].begin();
    }
    // 没有元素了
    else {
        mxCunt = x_cunt;
        miNum = *cunt[x_cunt].begin();
    }
  }

  // 获取当前区间状态答案。
  int getAns(int limit) {
    if(mxCunt >= limit) return miNum; 
    else return -1;
  }
};

class Solution {
public:
    vector<int> subarrayMajority(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        int B = 2 * (n + (int)sqrt(m) - 1) / (int)sqrt(m);

        // 重新排序 询问
        vector<int> qids(m);
        std::iota(qids.begin(), qids.end(), 0);
        sort(qids.begin(), qids.end(), [&](const int& x, const int& y) {
            int xb = queries[x][0]/B, yb = queries[y][0]/B;
            if(xb != yb) return xb < yb;
            else return queries[x][1] < queries[y][1];
        });

        // 离散化。
        auto dit = nums;
        sort(dit.begin(), dit.end());
        dit.erase(unique(dit.begin(), dit.end()), dit.end());
        // 保持离散化。
        vector<int> num_dit(n);
        for(int i = 0; i < n; i++) {
            int ditId = lower_bound(dit.begin(), dit.end(), nums[i]) - dit.begin();
            num_dit[i] = ditId;
        }

        message msg = message(n);

        vector<int> ans(m);

        
        // 处理询问
        int L = 0,  R = -1;
        for(int i = 0; i < m; i++) {
            int l = queries[qids[i]][0];
            int r = queries[qids[i]][1];
            int limit = queries[qids[i]][2];
            
            while(R < r) msg.add(num_dit[++R]);
            while(R > r) msg.del(num_dit[R--]);

            while(L < l) msg.del(num_dit[L++]);
            while(L > l) msg.add(num_dit[--L]);

            int tans = msg.getAns(limit);
            if(tans == -1) ans[qids[i]] = -1;
            else ans[qids[i]] = dit[tans];
        }
        return ans;
    }
};
```

如果依然出现常数问题可以适当降 B 调大。在上述代码中，调整$B = 2\frac{n}{\sqrt{m}}$ 才成功通过最后一个用例。
