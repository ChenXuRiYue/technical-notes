# 🏁 竞赛标题

🏆 排名 245/1711

🎈 过题数 3

🔖 算法标签 二分、搜索

# 💭 复盘

简单问题错误率非常高

<img src="https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250814125457998.png" alt="image-20250814125457998" style="zoom: 25%;" />



A 题错四发：对模型把握不清晰，边界没算好
D题：时间不足容易死脑筋一个劲儿想构造

无他：

1. 提高自检处理 bug 能力
2. 脑子有建模
3. 有其他的方法吗

# 🪾补题

## [Q4. 下一个特殊回文数](https://leetcode.cn/contest/weekly-contest-462/problems/next-special-palindrome-number/)

<img src="https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250814131154291.png" alt="image-20250814131154291" style="zoom:50%;" />

${\large {\color[RGB]{250, 157, 30}全解集}}$

观察发现 2，4，6，8 可以表达16位的某个偶数数字。因此仅需考虑 $17$ 位里的回文数。
观察发现最后奇数至多有一个 + 0 最多
因此最终数字选取上不超过：$2^4\times 5$  种。
而回文数总数 $Sum\lt 2^4\times 5 \times 8! =40,320  $ 。因此可以直接枚举出所有的回文数。

具体的枚举方式上：

1. 枚举所有数字组合
2. 枚举数字总数的全排列

```cpp
bool flag = false;
vector<long long> nums;

void init() {
  if(flag) return;
  flag = true;
  int a[] = {2, 4, 6, 8};
  int b[] = {1, 3, 5, 7, 9};
  for(int s = 0; s < (1 << 4); s++) {
    vector<int> choose;
    for(int i = 0; i < 4; i++) {
      if(s & (1 << i)) {
        choose.push_back(a[i]);
      }
    }
    // if(s != 6) continue;
    for(int i = 0; i < 6; i++) {


      // if(i != 5) continue;
      if(i != 5) choose.push_back(b[i]);
      if(choose.size() == 0) {
        continue;
      }

      // 求出对应数字的全排列
      int numType = choose.size();
      // 特殊处理 i == 0 情况
      // 排列
      int digSum = 0;
      for(int j = 0; j < numType; j++) {
        digSum += choose[j];
      }
      if(digSum > 17) { 
          if(i != 5) choose.pop_back();
          continue;
      }
      // 只考虑一半，剪纸
      digSum /= 2;


      // 处理出各个tag 代表的数字
      vector<int> id_num;

      if(i == 0) numType--;
      for(int j = 0; j < numType; j++) {
        for(int k = 0; k < choose[j] / 2; k++) {
          id_num.push_back(choose[j]);
        }
      }

      vector<int> permute(id_num.size());
      iota(permute.begin(), permute.end(), 0);
      do {
        long long cur = 0;
        for(int j = 0; j < permute.size(); j++) {
          cur = cur * 10 + id_num[permute[j]];
        }
        if(i != 5) {
          cur = cur * 10 + choose.back();
        }
        for(int j = permute.size() - 1; j >= 0; j--) {
          cur = cur * 10 + id_num[permute[j]];
        }
        nums.push_back(cur);
      } while(next_permutation(permute.begin(), permute.end()));
      if(i != 5) choose.pop_back();
    }
  }
  sort(nums.begin(), nums.end());
  nums.erase(unique(nums.begin(), nums.end()), nums.end());
}

class Solution {
public:
    long long specialPalindrome(long long n) {
        init();
        return *upper_bound(nums.begin(), nums.end(), n);
    }
};
```

一个恐怖的 🐞

if(i != 5) choose.push_back(b[i]); 

if(i != 5) choose.pop_back();

当使用了这种成对的语句时，注意要严格释放。

**调节 🐞 总结**

在修改这个 bug 的过程中，为了方便处理我使用了goto 发现 goto 对跳过语句块的初始化有严格要求。不推荐用 goto 的主要原因是它要求跳过的语句块中的初始化变量都要提前，造成语义理解困难。

${\large {\color[RGB]{250, 157, 30} 贪心算法}} $





${\large {\color[RGB]{250, 157, 30} dp 方法}} $







