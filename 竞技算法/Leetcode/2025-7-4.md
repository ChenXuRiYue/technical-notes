# ğŸ 460

ğŸ† 105

ğŸˆ 3

## å¤ç›˜

æ­£å¸¸å‘æŒ¥ï¼Œæ²¡æœ‰å‡ºç°ä¸å¿…è¦çš„ç½šæ—¶ã€‚ç¬¬å››é¢˜ç”±äºæ²¡æœ‰æŒæ¡çº¿æ€§åŸºï¼Œåˆ†è§£å‡ºæœ€å¤§ $XOR$ é—®é¢˜åæ— æ³•çªç ´ã€‚


## è¡¥é¢˜

[3630. åˆ’åˆ†æ•°ç»„å¾—åˆ°æœ€å¤§å¼‚æˆ–è¿ç®—å’Œä¸è¿ç®—ä¹‹å’Œ](https://leetcode.cn/problems/partition-array-for-maximum-xor-and-and/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ã€‚

å°†æ•°ç»„åˆ’åˆ†ä¸º **ä¸‰** ä¸ªï¼ˆå¯ä»¥ä¸ºç©ºï¼‰å­åºåˆ— `A`ã€`B` å’Œ `C`ï¼Œä½¿å¾— `nums` ä¸­çš„æ¯ä¸ªå…ƒç´  **æ°å¥½** å±äºä¸€ä¸ªå­åºåˆ—ã€‚

ä½ çš„ç›®æ ‡æ˜¯ **æœ€å¤§åŒ–** ä»¥ä¸‹å€¼ï¼š`XOR(A) + AND(B) + XOR(C)`

å…¶ä¸­ï¼š

- `XOR(arr)` è¡¨ç¤º `arr` ä¸­æ‰€æœ‰å…ƒç´ çš„æŒ‰ä½å¼‚æˆ–ç»“æœã€‚å¦‚æœ `arr` ä¸ºç©ºï¼Œç»“æœå®šä¹‰ä¸º 0ã€‚
- `AND(arr)` è¡¨ç¤º `arr` ä¸­æ‰€æœ‰å…ƒç´ çš„æŒ‰ä½ä¸ç»“æœã€‚å¦‚æœ `arr` ä¸ºç©ºï¼Œç»“æœå®šä¹‰ä¸º 0ã€‚

è¿”å›å¯å®ç°çš„æœ€**å¤§**å€¼

**æ³¨æ„:** å¦‚æœæœ‰å¤šç§åˆ’åˆ†æ–¹å¼å¾—åˆ°ç›¸åŒçš„ **æœ€å¤§** å’Œï¼Œä½ å¯ä»¥æŒ‰å…¶ä¸­ä»»ä½•ä¸€ç§åˆ’åˆ†

**å­åºåˆ—** æ˜¯æŒ‡ä¸€ä¸ªæ•°ç»„é€šè¿‡åˆ é™¤ä¸€äº›æˆ–ä¸åˆ é™¤ä»»ä½•å…ƒç´ ï¼Œä¸æ”¹å˜å‰©ä½™å…ƒç´ çš„é¡ºåºå¾—åˆ°çš„å…ƒç´ åºåˆ—

### æ€è·¯

è€ƒè™‘ æšä¸¾ AND çš„åºåˆ—ï¼Œåˆ™å°†é—®é¢˜ç®€åŒ–ä¸ºé›†åˆåˆ’åˆ†æˆä¸¤ç»„åºåˆ— $A$ï¼Œ$B$ï¼Œ $Maxium(Xor(A) + Xor(B))$

é’ˆå¯¹æ•°ä½è€ƒè™‘ä¸€ç§è´ªå¿ƒæ–¹æ³•ï¼š

å¯¹äºäºŒè¿›åˆ¶ä¸‹çš„æŸä¸€æ•°ä½ï¼Œå®šä¹‰è¯¥æ•°ä½ä¸º1 çš„ å…ƒç´ ä¸ªæ•°ä½ $Sum$

1. $Sum$ ä¸ºå¥‡æ•°ï¼Œæ— è®ºå¦‚ä½•é€‰æ‹©ï¼Œæœ€ç»ˆçš„ç»“æœè¯¥æ•°ä½ä¸º $1$
2. $Sum$ ä¸ºå¶æ•°ï¼Œæ— è®ºå¦‚ä½•é€‰æ‹©ï¼Œ$Xor(A) å’Œ Xor(B)$ åœ¨è¯¥æ•°ä½ä¸Šçš„å€¼ç›¸åŒ

å› æ­¤æœ‰å¦‚ä¸‹æ¨å¯¼ï¼š

å°† $Sum$ ä¸ºå¥‡æ•°çš„æ•°ä½ç»Ÿè®¡ä¸º $Sum_{odd}$

å°†é›†åˆå…ƒç´ ä¸­ $Sum$ ä¸ºå¥‡æ•°çš„æ•°ä½æŠ¹å¹³ã€‚

æ‰¾åˆ°æœ€å¤§åŒ–çš„å­åºåˆ—å¼‚æˆ–å’Œ $Xor_C$ ï¼ˆå¼‚æˆ–å’Œç»å…¸é—®é¢˜ï¼‰
$$
ans = 2 \times Xor_C + Sum_{odd}
$$




**code**

```C++
// ç±»å‹åˆ«å
typedef long long ll;
template<typename T = unsigned int>
class XorBasis {
    static_assert(std::is_same<T, unsigned int>::value || 
                  std::is_same<T, unsigned long long>::value, 
                  "XorBasis only supports unsigned int and unsigned long long");

    std::vector<T> base;

    // é«˜æ•ˆè·å–æœ€é«˜ä½ç´¢å¼• (0-indexed)ï¼Œè¿”å› -1 è¡¨ç¤º x == 0
    int high_bit(T x) const {
        if (x == 0) return -1;
#ifdef __GNUC__
        if (std::is_same<T, unsigned int>::value)
            return 31 - __builtin_clz(x);
        else
            return 63 - __builtin_clzll(x);
#else
        // é€šç”¨å›é€€ï¼šå¯ç§»æ¤ä½†ç¨æ…¢
        int b = 0;
        T t = x;
        while (t > 1) { t >>= 1; b++; }
        return b;
#endif
    }

public:
    // é»˜è®¤å¤§å°ï¼š32 æˆ– 64 ä½
    XorBasis() : base((std::is_same<T, unsigned int>::value ? 32 : 64), 0) {}
    explicit XorBasis(size_t n) : base(n, 0) {}

    // æ’å…¥ xï¼Œè¿”å›æ˜¯å¦ä¸ºçº¿æ€§æ— å…³ï¼ˆæˆåŠŸåŠ å…¥æ–°åŸºï¼‰
    bool insert(T x) {
        while (x) {
            int i = high_bit(x);
            if (!base[i]) {
                base[i] = x;
                return true;
            }
            x ^= base[i];
        }
        return false;
    }

    // æ±‚æœ€å¤§å¼‚æˆ–å€¼
    T max_xor() const {
        T res = 0;
        for (int i = static_cast<int>(base.size()) - 1; i >= 0; --i)
            if (base[i])  // ä»…å¯¹éé›¶åŸºæ“ä½œ
                res = std::max(res, res ^ base[i]);
        return res;
    }

    // å¯é€‰ï¼šæŸ¥è¯¢èƒ½å¦è¡¨ç¤ºæŸä¸ªå€¼
    bool can_represent(T x) const {
        for (int i = static_cast<int>(base.size()) - 1; i >= 0; --i)
            if (base[i] && (x ^ base[i]) < x)
                x ^= base[i];
        return x == 0;
    }
};

class Solution {
public:
    long long maximizeXorAndXor(vector<int>& nums) {
        int n = nums.size();
        long long ans = 0;
        vector<int> vec;
        const ll bitmask = (1LL << 31) - 1;
        for(int s = 0; s < (1 << n); s++) {
            ll tans = 0, andSum = bitmask;
            vec.clear();
            for(int i = 0; i < n; i++) {
                if((s >> i) & 1) {
                    andSum = andSum & nums[i];
                } else {
                    vec.push_back(nums[i]);
                }
            }

            if(andSum == bitmask) andSum = 0;
            XorBasis basics;

            unsigned int oddMask = 0;
            for(auto u : vec) {
                oddMask ^= u;
            }
            // cout << "andMask " << andSum << "\n";
            // cout << "oddMask " << oddMask << "\n";

            for(auto u : vec) {
                basics.insert(u & (~oddMask));
                // cout << (u & (~oddMask)) << "\n";
            }
            tans = andSum + oddMask + 2 * basics.max_xor();
            ans = max(ans, tans);

        }
        return ans;
    }
};
```
