# 📖 莫队

**掌握程度：** 可以口述
**学习契机：** lc 周赛

## 🗺️背景

>莫队算法是由莫涛提出的算法。在莫涛提出莫队算法之前，莫队算法已经在 Codeforces 的高手圈里小范围流传，但是莫涛是第一个对莫队算法进行详细归纳总结的人。
莫队算法可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。

From Oiwiki

## 📌应用

**满足以下形式的问题**：假设 $n = m$ ，那么对于序列上的区间询问问题，如果从$[l,r]$ 的答案能够扩展到$[l - 1,r]、[l + 1, r]、[l, r - 1]、[l, r + 1]$，(即与$[l,r]$相邻的区间）的答案，那么可以在$O(n\sqrt n)$ 的复杂度内求出所有询问的答案。

## 💭原理

${\color{Orange} \mathcal{{\large 机制} } }  $

**1. 分块处理：** 对序列以长 $B$ 分块
**2. 对询问重排序处理**：排序规则对于询问 $[l, r]$，以 $l$ 所在块的编号为第一关键字，$r$ 为第二关键字从小到大排序。
**3. 处理询问：** 顺序处理每个询问，暴力从上个区间的答案转移到下一个区间答案。

${\color{Orange} \mathcal{{\large 证明} } }  $

可以将处理询问过程看作处理若干观察任意块中的贡献：
维护一个窗口 $[l,r]$，每次暴力处理的过程中：

1. $r$ 是递增的。 对单块贡献为 $n$。平均贡献为 $\frac{n}{2}$
2. $l$ 左右抖动，每次幅度为$B$。
3. 跨块时 $l,r$ 发生调整处理新块的贡献，$l$ 每次最多偏移 $2B$，$r$ 最大偏移 $n$。该过程最多发生 $\frac{n}{B}$ 次。

综上 
$$
f = n\times \frac{n}{2B} + B \times m + (2B + n)\times \frac{n}{B}\\
=\frac{5n^2}{2B} + B\times m + 2n\\
$$
$$
图个方便可以简化得到：
\\
f = \frac{n^2}{B} + Bm
$$
$$
由基本不等式可知道\\
当 B = \frac{n}{\sqrt m} \\取得最小值  n\sqrt{q}
$$

关于 $2$ 步骤的处理简单做一些常熟收缩，最后复杂度都是 $O(n\sqrt{q})$。仅方便求出 $B$ 的最优取值。

${\color{Orange} \mathcal{{\large 扩展-回滚莫队} } }  $

在某些模型中，抖动的过程中 $$delete$$ 时，信息是难以维护的。我们想方法规避这点，即只维护 add 操作。于是我们可以不抖动直接将 $l$ 回滚在对应块的右边界，接着从右往左扫一遍块。时间复杂度上是不变的。在实现细节上，这种回滚操作需要 $r$ 总在块外，否则需要做麻烦的特判。因此可以先暴力处理所有长度小于 $B$ 的询问。

## 📄模版

模版分类两部分：

1. **维护的信息:**

```C++
struct message {
  // 维护基本信息
  
  // 初始化
  message() {
    
  }
  // 增加元素
  void add(int x) {
    // 补充增加逻辑
  }
  
  // 删除元素
  void del(int x) {
    // 补充删除逻辑
  }
  
  // 获取当前区间状态答案。
  int getAns() {
    
  }
}
```

2. **通用流程代码- 普通莫队**

```c++
// 求出块长 - 可以适当根据实现方法的最接近复杂度来调整最开始计算的时候是 2.5 * n /  sqrt(m)
int B = 2 * (n + (int)sqrt(m) - 1) / (int)sqrt(m);

// 重排序 query
vector<int> qids;
std::iota(qids.begin(), qids.end(), 0);
sort(qids.begin(), qids.end(),[&](const int& a, const int& b) {
  // 排序逻辑
} );

// 预处理 ans
vector<int> ans(queries.size());

// 处理询问
int L = 0, R = -1;
for(auto& qid : qids) {
  int ql = queries[qid].l, qr = queries[qid].r;
  // 维护区间
  while(r < qr) message.add(getId(nums[++r]));
  while(r > qr) message.del(getId(nums[r--]));
  while(l < ql) message.del(getId(nums[l++]));
  while(l > ql) message.add(getId(nums[--l]));
  
  int tans = message.getAns();
  ans[qid] = ans;
}

```



## 🌲发散

1. 莫队更多的是一种基础的分块思想，没有严格的模板

