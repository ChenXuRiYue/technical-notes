# 📌 进程间通信

IPC（进程间通信允许隔离的进程安全的进行通信，是构建更复杂应用程序的关键）

Tauri 使用异步消息传递，其中进程通过一些简单的数据表示交换请求和响应。
这种范式广泛应用于互联网的客户端-服务器模通信

## 📄 事件

事件是一次性、单向的 IPC 消息，最适合用于通信生命周期事件和状态变化。与[命令](https://v2.tauri.app/zh-cn/concept/inter-process-communication/#命令)不同，事件可以由前端*和* Tauri 核心发出。

![Diagram](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/index-0.svg)

## 📄 命令

Tauri 提供了类似于 外部函数接口的抽象，建立于 IPC 消息智商，主要API 为 `invoke` 类似于浏览器的 `fetch` API，允许前端调用 Rust函数、传递参数并接收数据。

该机制底层使用类似 JSON-RPC 的协议来序列化请求和响应，因此参数和返回数据必须能够序列化为 Json

![Diagram](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/index-1.svg)

## 📄 Brownfield 模式

**Brownfield 模式**（Brownfield Approach / Brownfield Development）是软件工程和系统架构中的一种开发或集成策略，与 **Greenfield（绿地）模式**相对。它的核心思想是：**在已有系统、代码、基础设施或业务流程的基础上进行开发、改造或集成，而不是从零开**

Tauri 中的Brownfield 模式：将 Tauri 集成到一个已有的前端项目。

Tauri.confi.json 中配置

```rust
{
  "tauri": {
    "pattern": {
      "use": "brownfield"
    }
  }
}
```

## 📄 隔离模式

使用 JavaScript 截获并修改前端向 Tauri Core 发送的 Tauri API 消息。

### 🔖 如何使用

隔离模式的核心在于在前端和 Tauri Core 之间注入一个安全的应用程序，用于拦截和修改传入的 IPC 消息。

Tauri 在加载页面时强制执行隔离模式，强制所有对 Tauri Core 的 IPC 调用都首先通过沙盒隔离应用程序进行路由。一旦消息准备好传递给 Tauri Core，它将使用浏览器的 [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) 实现进行加密，然后传递回主前端应用程序。到达主前端应用程序后，它将直接传递给 Tauri Core，然后像平常一样进行解密和读取。



### 🔖 IPC 消息步骤

1. Tauri 的 IPC 处理程序收到一条消息
2. IPC 处理程序 -> 隔离应用程序
3. `[sandbox]` 隔离应用程序钩子运行并可能修改消息
4. `[sandbox]` 使用运行时生成的密钥通过 AES-GCM 加密消息
5. `[encrypted]` 隔离应用程序 -> IPC 处理程序
6. `[encrypted]` IPC 处理程序 -> Tauri Core



### 🔖 性能影响

- 加密
- Tauri 应用程序每次启动时都会生成一个加密安全密钥。如果系统已经拥有足够的熵来立即返回足够的随机数，通常不会注意到这一点，这在桌面环境中非常常见。

### 🔖 创建隔离应用程序

创建一个小型的 hello-world 风格的 Isolation 应用，并将其连接到一个虚构的现有 Tauri 应用。它不会对传入的消息进行验证，只会将内容打印到 WebView 控制台。



```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Isolation Secure Script</title>
  </head>
  <body>
    <script src="index.js"></script>
  </body>
</html>
```



```javascript
window.__TAURI_ISOLATION_HOOK__ = (payload) => {
  // 不需要验证或修改任何内容，仅输出钩子中的内容
  console.log('hook', payload);
  return payload;
};
```

**配置：** 假设我们的主要前端 distDir 设置为 `../dist` 。我们还将 `Isolation` 应用程序输出到 `../dist-isolation` 。

```json
{
  "build": {
    "distDir": "../dist"
  },
  "app": {
    "security": {
      "pattern": {
        "use": "isolation",
        "options": {
          "dir": "../dist-isolation"
        }
      }
    }
  }
}
```



## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
### 问题描述：

### 关键结论：
```



