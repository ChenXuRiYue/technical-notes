# 📌 Maven-多模块

maven 引入了一套多模块的语法，其**本质**是未解决单体应用相组件化演进过程中的两个矛盾：

1. **物理隔离**：代码如何物理拆分，但又能作为一个整体被编译
2. **逻辑复用**：配置（如依赖版本、插件配置）如何在不同组件间共享，避免配置漂移

> 基于 Maven Model (POM 4.0.0)

## 📄 语法体系

### 🔖 元数据和身份（Metadata & Identity）

 这是 POM 的身份证，决定了它“是谁”以及“是什么类型”

1. **\<packaging> (打包类型)**

- **语法规范**：在多模块的**父工程（聚合工程）**中，此标签的值**必须**是 pom
- **官方定义**：

  > 默认是 jar。当设置为 pom 时，Maven 明白该项目不产生二进制构件（Artifact），而是作为其他项目的容器或元数据描述
  >

- **注脚**：这是开启“多模块模式”的唯一物理开关

2. **G.A.V (坐标体系)**

- **`<groupId>`**：组织标识（通常是反向域名）
- **`<artifactId>`**：项目标识（模块名）
- **`<version>`**：版本号
- **语法规范**：子模块如果继承了父模块，<groupId> 和 <version> 可以省略（默认继承父级）。但 *\<artifactId>* **必须**显式定义，因为它是子模块的唯一标识

### 🔖 结构关系 (Structural Relationships)

 这部分定义了模块之间的物理位置和逻辑血缘

3. **\<modules>(聚合/物理包含)**
   **位置**：仅在 \<packaging>pom\</packaging> 的父工程中有效
   **语法规范：**
   
   > 内部包含一系列 <module> 标签。值是**相对路径**（即子模块文件夹的名字），而不是 artifactId
   >
   
   **官方定义**：告诉 Maven Reactor（反应堆）哪些子目录需要被包含在本次构建中

----

4. **\<parent> *(继承/逻辑血缘)***

- **位置**：子模块的顶层
- **语法规范**：必须包含父级的 G.A.V 坐标

* **`<relativePath>` (关键语法)**：
- **默认值**：../pom.xml（去上一级目录找）
  
- **空值**：\<relativePath/>。这意味着**强制** Maven 去本地仓库或远程仓库找父 POM，而不查找本地文件系统
  
- **自定义值**：指定父 POM 的具体物理路径

### 🔖 治理和约束 (Governance & Constraints)

5. **\<properties> **(变量定义)
- **语法规范：**键值对结构
- **作用域：**全局可见。子模块可以读取父模块定义的属性。
- **常见用途：**
  - 统一管理版本号（如 <spring.version>5.3.0</spring.version>），在下文中通过 ${spring.version} 引用。


6. **\<depencyManagement> **(依赖管理)

- **语法规范：**

  - 位于 \<project> 根节点下
  - 内部结构与 \<depnecies>完全一致

- **官方定义：**声明依赖的元数据（版本、Scope、Exclusions），但不引入依赖

- **特殊语法：**Scope = import (BOM 模式)

  - 仅在 \<dependencyManagement> 中有效

  - 允许引入另一个 \<packaging>pom\</packaging> 的项目，将其 \<dependencyManagement> 中的配置“导入”到当前项目中。这是解决单继承限制的唯一语法手段（类似 Java 的 Interface）

7. \<pluginManagement> (插件管理)

- **位置：** \<build> 标签内部
- **语法规范：**与 **\<depencyManagement>** 逻辑完全一致
- **官方定义：** 用于锁定插件的版本（Version）和配置（Configuration），但不强制子模块执行该插件

### 🔖 执行和引用 （Excution & consumption）

8. **\<dependencies>** (依赖引用)

- 语法规范：
  - 如果父工程在 \<dependencyManagement> 中定义了该依赖，子模块**只需**声明 groupId 和 artifactId
  - **禁止**：在子模块中重复声明 version，除非你明确想要覆盖父级的标准（Override）
  -  **`<scope>`** (依赖范围)：
    - \* compile (默认)：编译、测试、运行都有效，且传递给下游
    - provided：编译、测试有效，**运行无效**（期望容器提供，如 Servlet API）。不传递
    - runtime：编译无效，测试、运行有效（如 JDBC 驱动）
    - test：仅测试有效（如 JUnit）。不传递

 *9.* **\<build>** (构建行为)

-  **`<plugins>`**：
  - **语法规范**：此处声明的插件会被**实际执行**
  -  如果父级 <pluginManagement> 已定义，此处只需写 groupId 和 artifactId 即可激活
-  **`<resources>`**：定义哪些文件（如 .xml, .properties）需要被复制到 classpath 中

### 🔖 总结清单
1. **身份象限**：
     packaging: 必须为 pom (父)
     GAV: 子模块可省 G/V，必填 A

2. **关系象限**：
     modules: 物理路径 (父指子)
     parent: 逻辑坐标 + relativePath (子指父)

3. **立法象限 (Management)**：
     properties: 变量池
     dependencyManagement: 版本字典 (含 scope: import)
     pluginManagement: 插件配置模版

4. **执法象限 (Usage)**：

     dependencies: 实际购物车 (省略版本)
     build/plugins: 实际流水线

## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题
maven 基础知识 —— 多模块

# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题
1. 我想知道 maven 多模块语法体系是什么？请你给我一个严谨完善的概念框架。

# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
### 问题描述：

### 关键结论：
```



