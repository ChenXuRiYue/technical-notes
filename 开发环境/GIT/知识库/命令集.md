# Git 

#### ❓1. merge 和 rebase 之间的差别是什么？

merge：保留协作历史，具有分支以及合并的结构。并且会将 merge 当作一个提交项。
rebase： 将对应新提交线性追加到 git 历史



#### ❓2. pull 和 fetch 之间的区别是什么？

git fetch ： 拉取远程分支到 本地的 orgin/tag
git pull: git fetch + git merge



#### ❓3. diff 命令

https://git-scm.com/docs/git-diff/zh_HANS-CN

本质上 git 的 diff 是找出两个文本文件行的最长上升子序列。其目标是：找出两个文本文件之间的最小编辑步骤，使得一个文件能变成另一个。

demo:

```txt
A
B
C
D
E
```

变为：

```txt
A
X
Y
C
Z
E
```

![image-20251111234539380](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/image-20251111234539380.png)

展示 diff

```txt
  A
- B
+ X
+ Y
  C
- D
+ Z
  E
```

可以看出，先求出了最长子序列：
A
C
E
剩余部分做先 + 后 - 。 

> Ps：进一步可以体会到 IDEA 的定制化。（对一些格式优化类型的修改，做了特殊的渲染，并非统一使用 +- 展示diff）。



为什么要用这样的算法呢？（自己的解答）

1. 对比最简单的按行比较：如果中间插入了多行将会导致噩梦级的错位宅男。
2. 修改的情形非常复杂并且不通用。 + - 优先可以强调两块的差异
3. 在维护阶段（简单修改是非常简明的。）大规模的重构应该是全面的审视了。由于大规模重构变化很多，难以得到一个简明实用算法和重构上的平衡。



论文：**1976 年 Unix `diff` 原始论文**

1. The goal of `diff` is to **minimize the number of lines that must be deleted and inserted** to transform one file into another.
2. We don’t care about ‘smart’ diffs. We care about **reproducible, minimal, and unambiguous** diffs. If you want pretty, use a GUI tool on top.



然后可以让 tongyi 大模型夸夸我；

![image-20251112000617989](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/image-20251112000617989.png)

![image-20251112000635972](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/image-20251112000635972.png)



#### ❓4.compare 语法意义

git 中并没有 compare 语句，git 增强工具：如 idea、gitlab 版本控制中心提供了增强；
其本质为，以下命令的组合：

```shell
git diff <start>..<end>
展示 <end> 相对于 <start> 的文件内容变化（即哪些行被增删改）。
这就是你在 Compare 页面看到的 “Changes” 标签页的内容。

git log <start>..<end>
显示从 <start> 到 <end> 之间所有的新提交（commit）。
对应 Compare 页面的 “Commits” 标签页。
```

