# ğŸ“Œ ä¿®æ”¹å…¨å±€é¡¹ç›®é…ç½®

æœ‰å¾ˆå¤šæ¨ªå‘å·¥ä½œï¼Œéœ€è¦ä¿®æ”¹å…¨å±€é¡¹ç›®çš„ä¸€äº›é…ç½®ã€‚ä¼ ç»Ÿæ–¹å¼ä¿®æ”¹å¤§é‡çš„é¡¹ç›®ï¼Œæ²Ÿé€šæˆæœ¬é«˜ï¼Œç²¾åŠ›è´Ÿæ‹…é‡ã€‚
è¯¥æ–‡æ¡£è€ƒè™‘ä¸€ç§æ–¹å¼ï¼Œæ‰“é€š gitlab ï¼Œé€šè¿‡ä¸€ä¸ª è¾ƒé€šç”¨çš„ prompt å®Œæˆå¤§å¤šæ•°æ¨ªå‘é¡¹ç›®ã€‚

## ğŸ”¨ ç¯å¢ƒå‡†å¤‡

- open code

- ä¸€ä¸ªèƒ½ç”¨çš„æ¨¡å‹ï¼š
  - 2026-02-02 å¯ä»¥æ˜¯å›½å†… GLM 4.7ã€Kimi2.5 ã€å›½å¤–çŸ¥åæ¨¡å‹è‹¥å¹²

# ğŸ“ Prompt

````markdown
# èƒŒæ™¯
ä½ æ˜¯ä¸€ä¸ªç†Ÿæ‚‰ Spring boot é¡¹ç›®çš„å·¥ç¨‹å¸ˆã€‚
æˆ‘éœ€è¦ä½ å¸®åŠ©å›¢é˜Ÿå®Œæˆä¸€é¡¹æ¨ªå‘å·¥ä½œï¼š
ä¿®æ”¹å›¢é˜Ÿå…¨å±€çš„ Spring boot é¡¹ç›®çš„ä¸€äº›é…ç½®ä¿¡æ¯ã€‚

**ç›¸å…³æŠ€æœ¯æ ˆ**
maven ç»“æ„çš„ Spring boot é¡¹ç›®
# å·¥ä½œå†…å®¹
å°† application-staging.yml æ–‡ä»¶ä¸­çš„ server:port æ”¹ä¸º 8080.

```yml
server:
  port: 8080
```

# æ€ç»´æ¨¡å¼
- è¯¥æ”¹åŠ¨ä¸šåŠ¡æ— å…³ï¼Œä»…å®šä½åˆ°æ”¹åŠ¨ç‚¹ï¼Œè€Œä¸éœ€è¦åˆ†æä»»ä½•é¡¹ç›®çš„å®ç°ç»†èŠ‚ã€‚

# é…ç½®ä¸Šä¸‹æ–‡
## gitlab
ç”±äºè¦è°ƒç”¨ gitlab apiã€‚åç»­æˆ‘å°†ä¸ºä½ æä¾›è„šæœ¬ã€‚
è¿™é‡Œæ˜¯ä¸€äº›ç›¸å…³é…ç½®ï¼Œéœ€è¦ä½ æ›¿æ¢ï¼š
- GITLAB_URL = 
- TOKEN = 

# å·¥ä½œæµï¼š
## æ‹‰å–æ‰€æœ‰é¡¹ç›®
æˆ‘å·²æ‰“é€šäº† gitlab çš„ä¸€äº›ä¿¡æ¯ã€‚ä½ å¯ä»¥é€šè¿‡è¿™ä¸ª python è„šæœ¬ï¼Œå¾—åˆ°æ‰€æœ‰é¡¹ç›®çš„ ssh clone å‘½ä»¤ã€‚
```python
import os
import requests
from urllib.parse import quote

GITLAB_URL = "https://git.sample.com/" # git åœ°å€
TOKEN = "aaaaaaaaaaaaaaaaaaaa"         # token ä»¤ç‰Œ

headers = {"PRIVATE-TOKEN": TOKEN}
params = {"simple": True,							 # ç®€æ´æ¨¡å¼
          "per_page": 100,             # æ¯é¡µ 100 ä¸ºå³°å€¼ã€‚éœ€è¦åˆ†é¡µæ‹‰å®Œ
          "with_shared": False,        # æ’é™¤å…±äº«é¡¹ç›®
          "page": 1}                   # é¡µå·
all_clone_urls = []

while True:
    resp = requests.get(f"{GITLAB_URL}/api/v4/groups/{namespace}/projects", headers=headers, params=params)
    projects = resp.json()
    if not projects:
        break
    for p in projects:
        all_clone_urls.append(p["http_url_to_repo"])
    params["page"] += 1

for url in sorted(all_clone_urls):
    print(url)
```

## æŒ‰æ˜ç¡®é¡ºåºå¤„ç†æ¯ä¸ªé¡¹ç›®
### åˆ¤å®šæ˜¯å¦è·³è¿‡
å› ä¸ºæ‹‰å–çš„æ˜¯å›¢é˜Ÿä¸­çš„æ‰€æœ‰é¡¹ç›®ã€‚
å› æ­¤éœ€è¦è¿‡æ»¤ä¸€äº›æ— å…³çš„é¡¹ç›®ã€‚ä½ éœ€è¦æ ¹æ®ä»¥ä¸‹ç‰¹å¾è¿‡æ»¤
- ä»… Spring boot é¡¹ç›®éœ€è¦æ”¹åŠ¨ã€‚
- è¯¥é¡¹ç›®ä»“åº“å­˜åœ¨ release åˆ†æ”¯
å¦‚æœä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶åˆ™è·³è¿‡è¯¥é¡¹ç›®ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªé¡¹ç›®ã€‚
### æ‰§è¡Œä¸‹è¿°å·¥ä½œæµ
#### 1. åˆ‡æ¢å¹¶åˆ›å»ºåˆ†æ”¯
- `git checkout release`
- `git pull`
- `git checkout -b feature/AI_fix_port`

#### 2. å®šä½åˆ° application-staging.yml
å¦‚æœæˆåŠŸå®šä½ç»§ç»­è¿›è¡Œã€‚
å¦‚æœè¯¥é¡¹ç›®æ²¡æœ‰è¯¥æ–‡ä»¶åˆ™åœ¨ Resource ä¸­ åˆ›å»º application-staging.yml

#### 3. å¤„ç†application-staging.yml æ–‡ä»¶
å®šä½åˆ°é…ç½®:
```yml
server:
  port: 

```
if è¯¥é…ç½®ä¸å­˜åœ¨
  åˆ™ç›´æ¥æ·»åŠ ç›®æ ‡é…ç½®
else
  å¦åˆ™ä¿®æ”¹ä¸º 8080
  
  
#### 4. æäº¤ merge åˆ° gitlab

```shell
curl --request POST \
  --url "https://gitlab.example.com/api/v4/projects/<PROJECT_ID>/merge_requests" \
  --header "PRIVATE-TOKEN: <YOUR_ACCESS_TOKEN>" \
  --header "Content-Type: application/json" \
  --data '{
    "source_branch": "feature/demo_ai_feature_114514",
    "target_branch": "main",
    "title": "feat: fix ",
    "description": "Automated MR via API",
    "remove_source_branch": true,
    "squash": false,
    "labels": "ai-generated"
  }'
```

#### 5. è·å–è¾“å‡ºæ‰€æœ‰ merge é“¾æ¥
- è¿™é‡Œæä¾›ä¸€ä¸ªè„šæœ¬
ä½ å¯ä»¥æŒ‰éœ€è°ƒæ•´ä»¥ä¸‹å†…å®¹ï¼š
- è¿‡æ»¤æ¡ä»¶
- è¾“å‡ºæ–¹å¼
æœ€ç»ˆæ•´ç†æˆä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰ merge_url çš„ txt ç»™æˆ‘
```python
import requests
from urllib.parse import quote
from typing import List, Dict, Any

# --- é…ç½® ---
GITLAB_URL = "https://git.sample.com/"
PRIVATE_TOKEN = "aaaaaaaaaaaaaaaaaaaa"
GROUP_PATH = "your-top-group"

HEADERS = {"PRIVATE-TOKEN": PRIVATE_TOKEN}

MR_FILTERS = {
    "state": "opened",
    "labels": "ai-generated",
    "target_branch": "release",
    "per_page": 100,
}


# --- å·¥å…·å‡½æ•° ---
def fetch_all_projects(group_path: str) -> List[Dict[str, Any]]:
    projects = []
    page = 1
    while True:
        resp = requests.get(
            f"{GITLAB_URL}/api/v4/groups/{quote(group_path, safe='')}/projects",
            headers=HEADERS,
            params={
                "include_subgroups": True,
                "with_shared": False,
                "per_page": 100,
                "page": page,
            },
        )
        resp.raise_for_status()
        data = resp.json()
        if not data:
            break
        projects.extend(data)
        page += 1
    return projects


def fetch_mr_urls(project_id: int) -> List[str]:
    urls = []
    page = 1
    while True:
        resp = requests.get(
            f"{GITLAB_URL}/api/v4/projects/{project_id}/merge_requests",
            headers=HEADERS,
            params={**MR_FILTERS, "page": page},
        )
        resp.raise_for_status()
        mrs = resp.json()
        if not mrs:
            break
        urls.extend(mr["web_url"] for mr in mrs)
        page += 1
    return urls


# --- ä¸»æµç¨‹ ---
def main() -> None:
    projects = fetch_all_projects(GROUP_PATH)
    for proj in projects:
        urls = fetch_mr_urls(proj["id"])
        for url in urls:
            print(url)


if __name__ == "__main__":
    main()
```

