# 📌 要不要 panic!

如果代码 panic，就没有恢复的可能。

选择返回 `Result` 值的话，就将选择权交给了调用者，而不是代替他们做出决定。调用者可能会选择以符合他们场景的方式尝试恢复，或者也可能干脆就认为 `Err` 是不可恢复的，所以他们也可能会调用 `panic!` 并将可恢复的错误变成了不可恢复的错误。因此返回 `Result` 是定义可能会失败的函数的一个好的默认选择。

## 📄 示例、代码原型和测试

1. 当你编写一个示例来展示一些概念时，在拥有健壮的错误处理代码的同时也会使得例子不那么明确。例如，调用一个类似 unwrap 这样可能 panic! 的方法可以被理解为一个你实际希望程序处理错误方式的占位符，它根据其余代码运行方式可能会各不相同。（示例代码，清晰度优先）
2. 原型设计：unwrap和expect方法在原型设计时非常方便。当我们准备好让程序更加健壮时，它们会在代码中留下清晰的标记。
3. 如果方法调用在测试中失败了，我们希望这个测试都失败，即便这个方法并不是需要测试的功能。因为 panic! 会将测试标记为失败，此时调用 unwrap 或 expect 是恰当的。 

## 📄 当我们比编译器知道更多的情况

当你有一些其他的逻辑来确保 `Result` 会是 `Ok` 值时，调用 `unwrap` 或者 `expect` 也是合适的。
编译器依然要求处理Result 值，较好的做法是,通过 expect 明文说明 Err 永远不会存在：

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
    .parse()
    .expect("Hardcoded IP address should be valid");
```

虽然人工通过代码检查了 OK 情况是不会出现的，但是随着代码的迭代更新，代码逻辑的变更。一旦出现该 panic! 报错信息，可以指导开发者重新审视，进而引入更健壮的 Result 处理方式。

## 📄 错误处理指导原则

考虑接口模型，用户和接口服务。接口服务遭遇错误考虑 panic!  或返回 Result。考虑几种情形：

1. 遭遇 **有害状态** 时建议使用 panic！。其中有害状态如 假设、保证、不可变性被打破的状态，非预期行为。更进一步的，此后运行的代码运行不依赖于这种有害状态，以及没有可行的手段来将有害状态信息编码进所使用的类型的情况。
2. 错误预期出现时，返回 Result 往往更合适。例如， Http请求返回了一个表明触发限流的状态。

当你的代码在进行一个使用无效值进行调用时可能将用户置于风险中的操作时，代码应该首先验证值是有效的，并在其无效时 `panic!`。尝试操作无效数据会暴露代码漏洞，如尝试访问不属于当前数据结构的内存是一个常见的安全隐患。

**核心理念：**

1. 函数通常都遵循**契约**（*contracts*）：它们的行为只有在输入满足特定条件时才能得到保证。当违反契约时 panic 是有道理的，因为这通常代表调用方的 bug，而且这也不是那种你希望所调用的代码必须处理的错误。



## 📄 创建自定义类型进行有效性验证

本节使用 Rust 类型思想进一步确保值的有效性，并尝试创建一个自定义类型以进行验证。

拆数游戏中，代码要求用户输入 1 到 100 的数字。有一种极端的情形，用户可能输入了非常大的数字，超过了输入的表达范围。或者用户输入了 非 1 到 100 的数字。为了安全，改进角度如下：

1. 在检查过程中使用 if 判断：

   ```rust
   loop {
       // --snip--
   
       let guess: i32 = match guess.trim().parse() {
           Ok(num) => num,
           Err(_) => continue,
       };
   
       if guess < 1 || guess > 100 {
           println!("The secret number will be between 1 and 100.");
           continue;
       }
   
       match guess.cmp(&secret_number) {
           // --snip--
   }
   
   ```

2. 一种更优的方式是在一个专用的模块中创建一个新类型将验证放入创建实例的函数中，而非到处重复这些检查

   ```rust
   pub struct Guess {
       value: i32,
   }
   
   impl Guess {
       pub fn new(value: i32) -> Guess {
           if value < 1 || value > 100 {
               panic!("Guess value must be between 1 and 100, got {value}.");
           }
   
           Guess { value }
       }
   
       pub fn value(&self) -> i32 {
           self.value
       }
   }
   
   ```

   

## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



