# 📌 包和 Crate

想象你写代码就像在建房子。一开始你一个人搭个小木屋，所有工具、材料都堆在院子里，没问题。但当你开始建摩天大楼，就需要：

- **分房间**（模块化）：厨房、卧室、机房……各司其职，互不干扰。
- **打包工具箱**（复用）：别人建类似房子时，可以直接拿你做好的“智能门锁模块”或“水电布线方案”，不用重造。
- **明确谁负责什么**（命名与边界）：避免两个人都以为对方装了窗户，结果没装。

Rust 的 **Crate** 就是这样一个“独立交付单元”——它可以是一个库（别人拿来用），也可以是一个可执行程序（最终产品）。而 **包（Package）** 是一个更上层的组织单位，它包含一个或多个 Crate，并附带元数据（比如名字、版本、依赖哪些别人的包）。



**引自AI：**

>你知道乐高吗？每个乐高套装（比如太空飞船）是一个完整的‘包’，里面有说明书（`Cargo.toml`）、零件（源代码），还能拼出一个能玩的东西（程序）。而每一个零件类型——比如‘2x4 红色砖块’——就有点像一个 **Crate**，它是乐高世界里最小的、可以被重复使用的标准单元。Rust 就是用这种方式，让程序员既能自己搭小玩具，也能和全世界的人一起拼巨型城市，还不怕零件撞车。

## 📄 Crate

Crate 是 Rust 编译器的最小单位。Crate 可以包含模块，模块可以定义在其他文件，然后和 Crate 一起编译。

**Demo**: 使用一个随机数的 Crate

```rust
use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("猜数字游戏\n");

    // mut 关键字定义了一个变量。省略则代表定义了一个常量
    let secret_number = rand::thread_rng().gen_range(1..=100);
    loop {
        println!("请输入一个数字\n");
        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            // 该语句使用处理常用错误
            .expect("读取失败\n");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("太小了"),
            Ordering::Greater => println!("太大了"),
            Ordering::Equal => {
                println!("正确！");
                break;
            }
        }
    }
}
```

### 🔖 二进制 Crate

二进制 Crate 可以被编译为可执行程序，比如命令行程序或服务端。它们必须有一个名为 `main` 函数来定义当程序被执行的时候所需要做的事情。

### 🔖 库 Crate

**库 crate**（*Library crates*）并没有 `main` 函数，它们也不会编译为可执行程序。相反它们定义了可供多个项目复用的功能模块。比如 [第二章](https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html#生成一个随机数) 的 `rand` crate 就提供了生成随机数的功能。大多数时间 `Rustaceans` 说的 “crate” 指的都是库 crate，这与其他编程语言中 “library” 概念一致。

## 📄 包

*包*（*package*）是提供一系列功能的一个或者多个 crate 的捆绑。一个包会包含一个 *Cargo.toml* 文件，阐述如何去构建这些 crate。

包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。

**创建包过程：**

```shell
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

Cargo 会给我们的包创建一个 *Cargo.toml* 文件。查看 *Cargo.toml* 的内容，会发现并没有提到 *src/main.rs*，因为 Cargo 遵循的一个约定：*src/main.rs* 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 *src/lib.rs*，则包带有与其同名的库 crate，且 *src/lib.rs* 是 crate 根。crate 根文件将由 Cargo 传递给 `rustc` 来实际构建库或者二进制项目。

在此，我们有了一个只包含 *src/main.rs* 的包，意味着它只含有一个名为 `my-project` 的二进制 crate。如果一个包同时含有 *src/main.rs* 和 *src/lib.rs*，则它有两个 crate：一个二进制的和一个库的，且名字都与包相同。通过将文件放在 *src/bin* 目录下，一个包可以拥有多个二进制 crate：每个 *src/bin* 下的文件都会被编译成一个独立的二进制 crate。

## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题
我在学习 包 和 Crate

# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题
如果一个没有基础的人别人问起我，我该怎么和他愉快的聊这个内容？
我尝试用最简单的话，描述这项技术本身的应用。

`包 和 Crate 模块系统中的重要概念。如Java的 package、jar包，Go 的 mod 类似，它们描述了 Rust中对代码、编译产物的管理以及复用。`

你认为我的讲述是恰当的吗？

# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



