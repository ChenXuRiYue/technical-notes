# 📌 定义模块来控制作用域和私有性



## 📄 模块小抄

这里提供一个简单的参考，用来解释模块、路径、`use`关键词和`pub`关键词如何在编译器中工作，以及大部分开发者如何组织他们的代码。

- **从 crate 根节点开始**: 当编译一个 crate, 编译器首先在 crate 根文件（通常，对于一个库 crate 而言是 *src/lib.rs*，对于一个二进制 crate 而言是 *src/main.rs*）中寻找需要被编译的代码。
- **声明模块**: 在 crate 根文件中，你可以声明一个新模块；比如，用`mod garden`;声明了一个叫做 garden
  的模块。编译器会在下列路径中寻找模块代码：
  - 内联，用大括号替换 `mod garden` 后跟的分号
  - 在文件 *src/garden.rs*
  - 在文件 *src/garden/mod.rs*
- 声明子模块: 在除了 crate 根节点以外的任何文件中，你可以定义子模块。比如，你可能在 src/garden.rs中声明mod vegetables;编译器会在以父模块命名的目录中寻找子模块代码：
  - 内联，直接在 `mod vegetables` 后方不是一个分号而是一个大括号
  - 在文件 *src/garden/vegetables.rs*
  - 在文件 *src/garden/vegetables/mod.rs*
- **模块中的代码路径**: 一旦一个模块是你 crate 的一部分，你可以在隐私规则允许的前提下，从同一个 crate 内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetables 模块下的 `Asparagus` 类型可以通过 `crate::garden::vegetables::Asparagus` 访问。
- **私有 vs 公用**: 一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用 `pub mod` 替代 `mod`。为了使一个公用模块内部的成员公用，应当在声明前使用`pub`。
- **`use` 关键字**: 在一个作用域内，`use`关键字创建了一个项的快捷方式，用来减少长路径的重复。在任何可以引用 `crate::garden::vegetables::Asparagus` 的作用域，你可以通过 `use crate::garden::vegetables::Asparagus;` 创建一个快捷方式，然后你就可以在作用域中只写 `Asparagus` 来使用该类型。



## 📄 在模块中对相关代码进行分组

**模块**让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。
因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的**私有性**（*privacy*）。私有项是不可为外部使用的内在详细实现。
我们也可以将模块和它其中的项标记为公开的，这样，外部代码就可以使用并依赖于它们。

### 🔖 Demo

对一个餐馆进行抽象：一个餐馆分前台（包括接待员为顾客安排座位、服务员接受点单和付款、调酒师制作饮品）、后台（厨师和烹饪人员在厨房工作、洗碗工清理餐具，以及经理处理行政事务）。使用模块的过程中对该部分代码抽象：

1. 创建 crate。`cargo new restaurant --lib` 我们创建了没一个 restaurant 的库

2. lib.rs 中的声明：

   ```rust
   mod front_of_house {
       mod hosting {
           fn add_to_waitlist() {}
   
           fn seat_at_table() {}
       }
   
       mod serving {
           fn take_order() {}
   
           fn serve_order() {}
   
           fn take_payment() {}
       }
   }
   ```
   语法规定：`mod 模块名 {模块主体}` 。
   模块内可以
   
   1. 定义其它的模块，像 `hosting` 和 `serving` 。 
   2. 结构体、枚举、常量、trait

通过使用模块，可以将相关的定义分组在一起，并指出他们为什么相关，保持程序的组织性。

```rust
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

src/main.rs , src/lib.rs 称为 crate 根。这两个文件的内容都分别在 crate模块结构的根组成了一个名为 create 的模块，该结构称为模块树。

树中的一些术语：兄弟、父子也用来描述模块嵌套结构中模块之间的关系。

1. Hosting 和 serving 是兄弟关系。
2. front_of_hose 和 hosting 是父子关系。

**整个模块植根于名为 crate 的隐式模块下。**

crate 作为隐式根模块，决定了 crate 内部所有子模块和顶层项的“绝对引用路径”，并成为内部可见性控制的锚点。
```rust
// src/lib.rs
mod a {
    pub fn f() {}
}

mod b {
    pub fn g() {
        crate::a::f();      // ✅ 绝对路径：从 crate 根出发
        super::a::f();      // ✅ 相对路径：b 和 a 是兄弟，父是 crate
        a::f();             // ❌ 错误！当前模块 b 中没有 a
    }
}
```



## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

````markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题
Rust中定义模块来控制作用域和私有性

# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题

# 问题阶段(记录了 talk 的过程，方便复用)
## 问题1：
**1.1 问题描述：**
```rust
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

src/main.rs , src/lib.rs 称为 crate 根。这两个文件的内容都分别在 crate模块结构的根组成了一个名为 create 的模块，该结构称为模块树。

树中的一些术语：兄弟、父子也用来描述模块嵌套结构中模块之间的关系。

1. Hosting 和 serving 是兄弟关系。
2. front_of_hose 和 hosting 是父子关系。

整个模块植根于名为 crate 的隐式模块下。

这是我的关于模块树的demo笔记。
我不太能明白这个 整个模块植根于名为 crate 的隐式模块下。是什么意思

**1.2 关键结论：**
crate 作为隐式根模块，决定了 crate 内部所有子模块和顶层项的“绝对引用路径”，并成为内部可见性控制的锚点。
```rust
// src/lib.rs
mod a {
    pub fn f() {}
}

mod b {
    pub fn g() {
        crate::a::f();      // ✅ 绝对路径：从 crate 根出发
        super::a::f();      // ✅ 相对路径：b 和 a 是兄弟，父是 crate
        a::f();             // ❌ 错误！当前模块 b 中没有 a
    }
}
```


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
````
