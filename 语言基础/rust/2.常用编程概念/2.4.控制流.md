# 📌 控制流

控制流语法根据条件是否为真来决定是否执行某些代码，以及根据条件是否为真重复运行一段代码的能力。

## 📄 if 表达式

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

If 后必须接到一个 bool 类型。非布尔值 不会自动转换为 布尔类型。



### 🔖 **使用 else if 处理多重条件**

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

### 🔖 Let 中使用 if

if 是一个表达式，会返回代码块的值。而代码块的值是最后一个表达式的值。

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```







## 📄 循环

控制重复执行一段代码，并且为其设置明确边界。
Rust 提供了三种 循环：loop、while、for

### 🔖 使用 loop 重复执行

```rust
loop {
  println!("agin!");
}
```

语法上不带终止条件。只能等 程序退出，或使用 break 语句构造内部的结束逻辑。



### 🔖 从循环中返回值

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
### 🔖 循环标签

循环标签用于嵌套循环场景。使用循环标签绑定循环，结合 break、cntinue 可以精确跳出、跳到下一循环的层级。

1. break： 跳出制定标签的
2. continue：跳转到 标签对应循环的下一轮

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

result

```rust
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2

```

### 🔖 while 条件循环

```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println!("{number}");
    
    number -= 1;
  }
  
  prinln!(number);
}
```



### 🔖 使用 for 遍历集合

rust 中的 for 注重简单的 for。 对某集合的元素遍历。

1. 基于 rust 语法内置库的集合
2. 基于已定义集合

```rust
fn main() {
    let a = [1, 2, 3, 4];

    println!("for begin");
    for i in a {
        print!("{i} ")
    }
    println!();
    println!("for end");

    println!();

    for i in 1..5 {
        print!("{i} ");
    }
    println!("");
}
```

更复杂的逻辑可以通过 loop，while 等定义实现。某种意义上遮蔽性之下，可以避免重复定义某个无关紧要的值 如 i 这种即用即毁的变量。

```rust
fn main() {
    const LEN : i32 = 20;

    let mut i = 1;
    loop {
        print!(" {i}");
        i = i + 1;
        if i > LEN {
            println!{" end"};
            break;
        }
    }

    let mut i = LEN;
    loop {
        print!(" {i}");
        i = i - 1;
        if i <= 0 {
            println!(" end");
            break;
        }
    }

}

```



## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



