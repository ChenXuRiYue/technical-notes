# 📌 所有权

**所有权** 是 Rust 用户如何管理内存的一种规则。每一门语言都必须管理其运行时使用计算机内存的方式：

1. java、go 等具有垃圾回收机制。该种运行机制可以有规律性地寻找不再使用的内存
2. C、C++ 中要求程序员亲自的分配释放内存
3. 

## 📄 所有权与 堆、栈

栈和堆是很多语言在内存中管理值的方式。他们的主要差别在于新建对象布局、访问速度上。栈是后进先出的结构，其分配内存总是增长式的。值入栈往往快于堆上分配内存。堆上访问对象需要通过指针访问（==栈访问对象是通过什么方式呢？==）

**跟踪**哪部分代码正在使用堆上的哪些数据，最大限度的**减少堆**上重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。

## 📄 所有权规则

1. Rust 的每一个值都有一个所有者
2. 值在任一时刻有且仅有一个所有者
3. 当所有者离开作用域时，这个值将被丢弃

## 📄 变量作用域

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效

```

## 📄 String 类型

通过 String 类型来说明 Rust 中的所有权。因为 String 长度时可变的数据类型，它需要分配到堆中。因此通过 String 数据来了解所有权机制。

String 的一些基本特性：

```rust
let mut s = String::from("hello");
s.push_str(",world");
println!("{s}");
```

## 📄 内存与分配

字符串字面值是在编译时即知道内容，他可以直接编码进最终的可执行文件中。而String 它的大小是未知的。编译器需要支持一个可变可增常的文本片段，这需要在堆上分配一块在编译时未知大小的内存来存放内容。

1. 必须在运行时向内存分配器（memory allocator） 请求内存
2. 需要一个当我们处理完 String 时将内存返回给分配器的方法。



和 GC 不同（如 Java GC 定期的分析对象引用、确定对象不可达之后将对象的内存自动释放。）
Rust 采取一种简单保守的策略：**内存在拥有它的变量离开作用域后就被自动释放。** 

```rust
{
    let s = String::from("hello"); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
```


### 🔖 dmeo1

```rust
let x = 5;
let y = x;
```

将 5 绑定到 `x`；接着生成一个值 x 的拷贝并绑定到 `y`；

### 🔖 dmeo2

```rust
let s1 = String::from("hello");
let s2 = s1;
```

在堆中生成一个 String 存储结构：

**S1（字符串句柄）存储在栈中**

1. 指向字符串内容内存的指针 ptr
2. 长度 len
3. 容量 cap

**content** : 字符串内容，存储在堆中。

​    ![image-20250920143326862](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250920143326862.png)

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```

以上行为不被允许的：

>  简单推断：
>
> 由于浅拷贝 S1,S2 的字符串内容指针指向同一片实例。s1,s2 由变量离开作用域释放规则，会出现二次内存释放错误。
>
> 事实上：rust 中默认的拷贝行为和一般的浅拷贝是有差别的。在 rust 中使用了移动机制机制。将对 s1 标记成无效的。

编译器报错：

报错提示如下：==-- value moved here==

```rust
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

```

Ps：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何**自动**的复制都可以被认为是对运行时性能影响较小的。

### 🔖 作用域与赋值

当为一个已有变量赋一个全新的值时，Rust会立即调用 drop 并且释放原始值的内存。



### 🔖 使用克隆的变量与数据交互

当一个类型在栈上存储了指向堆内存的指针（如 `String`、`Vec<T>`），默认的赋值或传参会转移所有权。若需复制堆数据而非移动，应调用 `.clone()`。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {s1}, s2 = {s2}");
```



### 🔖 只在栈中的数据：拷贝

```rust
    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
```

对于编译时已知大小的类型被整个存储在栈上，赋值时并不会出现移动，而是拷贝。



## 📄 所有权与函数

❗️将值传递给函数和变量赋值的远离类似的。可能会发生移动！

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
    println!("{}", x);              // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{some_string}");
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{some_integer}");
} // 这里，some_integer 移出作用域。没有特殊之处
```

如果后续再使用 s 将会出现编译错误。



## 📄 返回值和作用域

返回值也是同理的，return 发生在作用域结束之前。等效为 return 的值在作用域结束前发生了赋值。

```rust
fn main() {
    let s1 = gives_ownership();        // gives_ownership 将它的返回值传递给 s1

    let s2 = String::from("hello");    // s2 进入作用域

    let s3 = takes_and_gives_back(s2); // s2 被传入 takes_and_gives_back, 
                                       // 它的返回值又传递给 s3
} // 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生
  // s1 移出作用域并被丢弃

fn gives_ownership() -> String {       // gives_ownership 将会把返回值传入
                                       // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域

    some_string                        // 返回 some_string 并将其移至调用函数
}

// 该函数将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String {
    // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```



## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

````markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题
rust 的所有权规则

# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题
rust 中对于 String 的一个变量应该怎么描述呢？java 中我可以称为引用对象它指向了堆中的一个对象。java中我明确引用了 基本变量的区别。而 rust 中呢？
简单来说我目前在写一个笔记，我起笔是：对于 String，如果需要深度复制 String 中堆上的数据，可以调用 clone 的常用方法。（我想堆 String 这个主语替换成更通用的描述）
# 问题阶段(记录了 talk 的过程，方便复用)
## 问题1
1.1 问题描述：
Rust 中出现了变量移动。我应该怎么理解这点呢？
```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```
s1 无效还是 s1 中的指针无效了？
1.2 关键结论：
s1 会被标记为无效

--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
````
