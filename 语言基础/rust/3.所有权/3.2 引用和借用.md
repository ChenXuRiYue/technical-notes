# 📌 引用和借用

## 📄 背景

单纯以所有权与普通类型的值编写代码：

```rust
fn main() {
    let  s = String::from("demo");
    f(s);
    g(s);

}

fn f(t : String) {
    println!("{} in f", t);
}

fn g(t : String) {
    println!("{} in g", t);
}
```

**报错：**

```shell
   Compiling guessing_game v0.1.0 (/Users/mi/rust_code/guessing_game)
error[E0382]: use of moved value: `s`
 --> src/main.rs:4:7
  |
2 |     let  s = String::from("demo");
  |          - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     f(s);
  |       - value moved here
4 |     g(s);
  |       ^ value used here after move
  |
note: consider changing this parameter type in function `f` to borrow instead if owning the value isn't necessary
 --> src/main.rs:8:10
  |
8 | fn f(t : String) {
  |    -     ^^^^^^ this parameter takes ownership of the value
  |    |
  |    in this function
help: consider cloning the value if the performance cost is acceptable
  |
3 |     f(s.clone());
  |        ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
```

所有权限制下，如果不使用其它手段，每次函数穿参都会使输入参数移动到接受参数。这意味着需要做大量的clone 深度拷贝。

Rust 引入了 **引用** 和 **借用**机制解决该问题。

## 📄 引用

引用是一个地址，通过地址可以访问存储于该地址的属于其它变量的数据。与指针不同，引用在其声明周期内保证指向某个特定类型的有效值。

### 🔖 **demo**

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

![image-20250922233144691](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/typora/image-20250922233144691.png)



### 🔖 语法

1. 使用引用：和指针很像：`&s` 代表了 s 的引用。其类型为 & （S 的类型）。如上 demo。
2. 解引用：`*ptr`

### 🔖 借用

创建一个引用的行为称为借用。

尝试借用的修改变量：(引用和变量类似、默认下不可以修改被引用的值)

```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

```rust
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

```

## 📄  可变引用及限制

和普通变量一样，使用 mut 正确修饰可变引用即可。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

1. 将 引用对象改为 mut。因为引用修改的对象就是指向的对象。修改目标本身要是可变的。
2. 创建一个可变引用：`&mut s`

### ❌ 一个可变

如果有一个对该变量的可变引用，不能再创建对该变量的引用。

```rust
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);

```

```rust
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

```

Rust 通过该方式限制了灵活的可变性。这样可以使得 Rust 在编译时避免**数据竞争**。即避免一下情形发生：

1. 两个或更多指针修同时访问同一数据
2. 至少有一个指针被用来写数据
3. 没有同步数据访问机制

###  ❌ 可变、不可变不共存 

```rust
  let mut s = String::from("hello");

  let r1 = &s; // 没问题
  let r2 = &s; // 没问题
  let r3 = &mut s; // 大问题

  println!("{}, {}, and {}", r1, r2, r3);
```

```rust
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

```

然而 Rust 的编译器是灵活的。它可以根据不可变引用最后一次使用，来灵活调整它们共存。换句话来说：
**一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。**

```rust
  let mut s = String::from("hello");

  let r1 = &s; // 没问题
  let r2 = &s; // 没问题
  println!("{r1} and {r2}");
  // 此位置之后 r1 和 r2 不再使用

  let r3 = &mut s; // 没问题
  println!("{r3}");
```



## 📄  悬垂引用

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个**悬垂指针**（*dangling pointer*）

Rust中通过一下手段避免了这点：

1. 编译器确保数据不会再引用之前离开作用域

   ```rust
   fn main() {
       let reference_to_nothing = dangle();
   }
   
   fn dangle() -> &String {
       let s = String::from("hello");
   
       &s
   }
   ```

   ```rust
   $ cargo run
      Compiling ownership v0.1.0 (file:///projects/ownership)
   error[E0106]: missing lifetime specifier
    --> src/main.rs:5:16
     |
   5 | fn dangle() -> &String {
     |                ^ expected named lifetime parameter
     |
     = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
   help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
     |
   5 | fn dangle() -> &'static String {
     |                 +++++++
   help: instead, you are more likely to want to return an owned value
     |
   5 - fn dangle() -> &String {
   5 + fn dangle() -> String {
     |
   
   error[E0515]: cannot return reference to local variable `s`
    --> src/main.rs:8:5
     |
   8 |     &s
     |     ^^ returns a reference to data owned by the current function
   
   Some errors have detailed explanations: E0106, E0515.
   For more information about an error, try `rustc --explain E0106`.
   error: could not compile `ownership` (bin "ownership") due to 2 previous errors
   
   ```

   

## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



