# 📌 使用字符串存储UTF-8编码文本

## 📄 什么是字符串？

字符串（`String`）类型由 Rust 标准库提供，而不是编入核心语言，它是一种可增长、可变、可拥有、UTF-8 编码的字符串类型。当 Rustaceans 提及 Rust 中的 "字符串 "时，他们可能指的是 `String` 或 string slice `&str` 类型，而不仅仅是其中一种类型。

## 📄 新建字符串

1. 新建一个空的字符串

```rust
let mut s = String::new();
```

2. 通过字面值加载空字符串

```rust
let data = "initial contents";

let s = data.to_string();

// 该方法也可直接用于字符串字面值：
let s = "initial contents".to_string();

```

3. 通过 from 加载

```rust
let s = String::from("initial contents");
```

字符串根据 UTF-8 编码：因此下述字符串都是有效的

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שלום");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```



## 📄 更新字符串

字符串不仅可以更新长度结构，也可以改变字符串的内容。

### 🔖 使用 `push_str` 和 `push` 附加字符串

可以通过 `push_str` 方法来附加字符串 slice

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

`push` 方法被定义为获取一个单独的字符作为参数，并附加到 `String` 中。

```rust
let mut s = String::from("lo");
s.push('l');
```

### 🔖 使用 + 运算符或 format! 宏 拼接字符串

**\+ 运算符**

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
```

\+ 号的运算符标准库中的实现类似：`fn add(self, s: &str) -> String {`

细节如下：

1. 第二个参数使用了引用。
2. add 获取了 self 的所有权。

**format! 宏**
```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```



## 📄 索引字符串

在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。然而Rust中的字符串不支持索引

```rust
let s1 = String::from("hi");
let h = s1[0];
```

报错：

```rust
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --> src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>
  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`
          but trait `SliceIndex<[_]>` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index<{integer}>`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error

```

Rust中的字符串不支持索引：

### 🔖 内部原理

String 内部是一个 Vec\<U8> 的封装。因为字符串的索引并不总是对应一个有效的 Unicode标量值，Rust 避免这些不安全的行为发生。

### 🔖 字节、标量值和字形簇

考虑一段在梵文内部的结构形式：

字节：

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

标量值：

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

字形簇：

```rust
["न", "म", "स्", "ते"]
```



## 📄 字符串 slice

如果尝试用类似 `&hello[0..1]` 的方式对字符的部分字节进行 slice，Rust 会在运行时 panic，就跟访问 vector 中的无效索引时一样：

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];

```



```
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

```



## 📄 遍历字符串方法

明确需要字符还是字节：

+ 需要字符： 使用chars，获取若干个独立的 Unicode

```rust
#![allow(unused)]
fn main() {
for c in "Зд".chars() {
    println!("{c}");
}
}

З
д

```

- `bytes` 方法返回每一个原始字节

```rust
for b in "Зд".bytes() {
    println!("{b}");
}

208
151
208
180

```

## 🌳 生长思考

1. 重新理解编码，及其在软件工程中的通式

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



