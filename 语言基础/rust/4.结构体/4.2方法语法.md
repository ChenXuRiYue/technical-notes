# 📌 方法语法

方法和函数类似，使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。区别在于，方法是在结构体上下文中定义的，并且它们第一个参数总是 `self`。

在结构体语境中，使用方法代替函数的好处是：除了可食用方法语法不需要在每个函数签名中重复self 的类型之外，其主要好处在于组织性。

1. 将某个类型实例的事情全部在 impl 中实现。
2. 将当前

## 📄 定义方法

**demo 示例**

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50
    };
    
    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

1. **impl** 块语法讲所有内容与 Rectangle 类型关联。
2. 方法的签名中，方法的第一个参数必须有一个名为 `self` 的 `Self` 类型的参数。
3. 使用 `&self` 来替代 `rectangle: &Rectangle`，`&self` 实际上是 `self: &Self` 的缩写。在一个 `impl` 块中，`Self` 类型是 `impl` 块的类型的别名。
4. 方法可以选择获得 `self` 的所有权，或者像我们这里一样不可变地借用 `self`，或者可变地借用 `self`，就跟其他参数一样。

### 🔖 方法命名

1. 方法可以和结构体中某个属性名称相同

	```rust
	impl Rectangle {
	    fn width(&self) -> bool {
	        self.width > 0
	    }
	}
	
	fn main() {
	    let rect1 = Rectangle {
	        width: 30,
	        height: 50,
	    };
	
	    if rect1.width() {
	        println!("The rectangle has a nonzero width; it is {}", rect1.width);
	    }
	}
	```

### 🔖 自动解引用

C++ 中调用方法一般需要用到两个运算符：`.`  或者 `->`

Rust 中 引用存的是地址，类似于指针。它引入了 自动解引用的语法糖（和 go 类似）如下：
```rust
p1.distance(&p2);
(&p1).distance(&p2);
```

两行语句是一致的。

### 🔖 带有更多参数的方法

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```




## 📄 关联函数

在 impl 块中 定义的函数为 **关联函数**。
调用方法：`let sq = Rectangle::squre(3);`

## 📄 多个 impl 块

每个结构体都允许拥有多个 impl 块，每个方法都有自己的 impl 块：

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

```



## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题


# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题


# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
1.1 问题描述：

1.2 关键结论：
```



