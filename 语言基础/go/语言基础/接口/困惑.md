### 问题复现
```go
package main

import "fmt"

type inter interface {
	sayHello()
	sayNoHello()
}

type A struct {
	member int32
}

func (a A) sayHello() {
	fmt.Println("hello")
}

func (a *A) sayNoHello() {
	fmt.Println("sayNoHello")
}

func main() {
	var t1 inter = A{1000}    // 值类型赋值，失败
	var t2 inter = &A{1000}   // 指针类型赋值，成功
	t2.sayHello()
	t2.sayNoHello()
}
```

- `var t1 inter = A{1000}` 会报错：
  ```
  cannot use A{1000} (type A) as type inter in assignment:
  A does not implement inter (sayNoHello method has pointer receiver)
  ```
- `var t2 inter = &A{1000}` 成功，输出：
  ```
  hello
  sayNoHello
  ```

**困惑**：
- 静态检查时，为什么值类型 `A` 被认为没有实现 `inter`（因为 `sayNoHello()` 是指针方法）。
- 但对指针类型 `*A`，Go 却认可它实现了 `inter`，包括值接收者方法 `sayHello()`。
- 这看起来像是对 `*A` 的“特殊待遇”，显得不一致。

### Go 的接口实现规则
要理解这个现象，我们需要明确 Go 中接口实现的定义和检查方式：

1. **接口实现的本质**
   - 一个类型 `T` 实现接口 `I`，意味着类型 `T` 提供了接口 `I` 中声明的所有方法，并且这些方法可以通过 `T` 的值直接调用。
   - 检查是静态的，基于类型的定义，而不是运行时的动态行为。

2. **方法集（Method Set）**
   - Go 为每种类型定义了一个“方法集”，表示该类型可以调用的方法。
   - 方法集的规则：
     - 值类型 `T` 的方法集：只包括接收者为 `T` 的方法。
     - 指针类型 `*T` 的方法集：包括接收者为 `T` 和 `*T` 的方法。

#### 值类型 `A` 的方法集
- `A` 的方法：
  - `sayHello()`（接收者是 `A`）。
  - 不包括 `sayNoHello()`（接收者是 `*A`）。
- 方法集：`{sayHello()}`。
- 检查 `inter` 接口（需要 `sayHello()` 和 `sayNoHello()`）：
  - `A` 缺少 `sayNoHello()`，因此 `A` 没有实现 `inter`。

#### 指针类型 `*A` 的方法集
- `*A` 的方法：
  - `sayHello()`（接收者是 `A`，`*A` 可以通过解引用调用）。
  - `sayNoHello()`（接收者是 `*A`，直接匹配）。
- 方法集：`{sayHello(), sayNoHello()}`。
- 检查 `inter` 接口：
  - `*A` 包含所有方法，`*A` 实现了 `inter`。

### 为什么这样设计
你觉得“奇怪”的点在于：Go 在检查 `*A` 时，认可了值接收者方法 `sayHello()`，但对 `A` 却不认可指针接收者方法 `sayNoHello()`。这其实不是“特殊待遇”，而是 Go 方法集规则的自然结果：

1. **值接收者方法的普适性**
   - 当方法接收者是值类型 `T` 时，`*T` 可以通过解引用（`*p`）调用该方法。
   - 这是因为解引用是安全的、无损的操作，Go 将其纳入 `*T` 的方法集。
   - 所以 `*A` 的方法集包括 `sayHello()`。

2. **指针接收者方法的专属性**
   - 当方法接收者是 `*T` 时，`T` 不能直接调用，因为 Go 不会自动取址（`&a`）来满足方法集的要求。
   - 取址涉及创建新指针，Go 选择不自动执行这种操作，以保持显式性和可预测性。
   - 所以 `A` 的方法集不包括 `sayNoHello()`。

3. **静态检查的类型视角**
   - 在 `var t1 inter = A{1000}` 中，Go 检查的是类型 `A` 的方法集。
     - `A` 只有 `sayHello()`，缺少 `sayNoHello()`，失败。
   - 在 `var t2 inter = &A{1000}` 中，Go 检查的是类型 `*A` 的方法集。
     - `*A` 有 `sayHello()` 和 `sayNoHello()`，成功。
   - Go 始终基于赋值的类型（`A` 或 `*A`）进行检查，没有“偏袒”，只是方法集不同。

### 为什么看起来“奇怪”
你的困惑可能来自直接调用和接口检查的差异：
- **直接调用**：
  ```go
  a := A{1000}
  a.sayNoHello()  // 成功，自动取址为 &a
  ```
  - Go 在运行时对可寻址变量自动取址，灵活处理。
- **接口赋值**：
  ```go
  var t inter = A{1000}  // 失败
  ```
  - Go 在编译时只看类型 `A` 的方法集，不考虑运行时取址。

对 `*A` 的检查包括值方法，是因为方法集规则明确规定了这一点，而不是 Go 在静态检查时“动态调整”。这不是不一致，而是两种场景的规则不同：
- 直接调用：运行时调整（取址或解引用）。
- 接口实现：编译时检查方法集。

### 更深层次的设计逻辑
Go 的这种设计有其道理：
1. **显式性**：
   - 值类型 `A` 不自动包含指针方法，避免隐藏的指针创建。
   - 指针类型 `*A` 包含值方法，因为解引用是直观的。
2. **安全性**：
   - 解引用（`*p`）不会改变状态，安全。
   - 取址（`&a`）可能引入副作用，Go 要求显式。
3. **一致性**：
   - 方法集规则统一应用于所有场景（接口、调用等）。

### 解决“奇怪感”的视角
与其觉得 `*A` 被“特殊关注”，不如这样理解：
- `A` 和 `*A` 是两种不同的类型，各有自己的方法集。
- `A` 的方法集是 `{sayHello()}`，不足以实现 `inter`。
- `*A` 的方法集是 `{sayHello(), sayNoHello()}`，足以实现 `inter`。
- Go 对两者的检查是公平的，只是 `*A` 的方法集天然更丰富。

### 验证
如果把方法反过来：
```go
func (a *A) sayHello() { fmt.Println("hello") }
func (a A) sayNoHello() { fmt.Println("sayNoHello") }
```
- `A` 的方法集：`{sayNoHello()}`，不实现 `inter`。
- `*A` 的方法集：`{sayHello(), sayNoHello()}`，实现 `inter`。
- 结果相同：`var t inter = &A{1000}` 成功，`var t inter = A{1000}` 失败。

### 结论
“`*A` 关注了它实现了什么方法”并不奇怪，这是 Go 方法集规则的直接体现：
- `*A` 的方法集包括值接收者和指针接收者方法，因此能实现 `inter`。
- `A` 的方法集只包括值接收者方法，无法实现 `inter`。
- 静态检查始终基于类型的方法集，没有例外。

这种设计是一致的，只是值类型和指针类型的方法集定义不同，导致了表面上的“不对称”。希望这个解释消除了你的“奇怪感”，如果还有疑问，欢迎继续讨论！