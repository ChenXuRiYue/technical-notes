### 1. **扩容的基本流程**
当切片的长度等于容量（`len == cap`）时，调用 `append` 会触发以下步骤：
1. **计算新容量**：根据当前容量和所需空间，决定新的容量大小。
2. **分配新数组**：创建一个新的底层数组，容量为计算出的新值。
3. **数据迁移**：将原有数组的数据复制到新数组中。
4. **追加元素**：在新数组中添加新元素。
5. **更新切片**：返回指向新底层数组的切片，更新 `len` 和 `cap`。

---

### 2. **容量增长规则**
Go 的扩容策略并不是简单地将容量翻倍，而是根据当前容量的大小和元素类型的大小，采用分阶段的增长规则。这些规则在 Go 的源码（`runtime/slice.go` 中的 `growslice` 函数）中有明确实现。以下是详细逻辑：

#### (1) **小容量时的翻倍增长**
- 当当前容量较小时（通常小于 256），新容量会直接翻倍，即 `newCap = oldCap * 2`。
- 这是为了快速适应小规模数据增长的需求。

示例：
```go
slice := make([]int, 0, 1)  // cap = 1
slice = append(slice, 1)     // len = 1, cap = 1
slice = append(slice, 2)     // cap 不足，扩容
// 新容量 = 1 * 2 = 2
fmt.Println(len(slice), cap(slice))  // 2, 2
slice = append(slice, 3)     // cap 不足，扩容
// 新容量 = 2 * 2 = 4
fmt.Println(len(slice), cap(slice))  // 3, 4
```

#### (2) **大容量时的渐进增长**
- 当容量较大时（通常大于或等于 256），直接翻倍会导致内存浪费，因此 Go 采用更保守的增长策略。
- 新容量计算公式大致为：`newCap = oldCap + (oldCap + 3*threshold) / 4`，其中 `threshold` 是一个与内存对齐相关的阈值（通常与元素大小相关）。
- 这种策略使容量增长逐渐趋于线性，接近 1.25 倍（而不是 2 倍）。

示例（假设 `int` 占用 8 字节，容量超过 256）：
```go
slice := make([]int, 256, 256)
slice = append(slice, 1)
// 旧容量 = 256，新容量 ≈ 256 * 1.25 = 320
fmt.Println(len(slice), cap(slice))  // 257, 320
```

#### (3) **内存对齐的调整**
- Go 的内存分配器会确保新数组的大小是对齐到某个字节边界的（通常是 8 字节或 16 字节，具体取决于平台和元素大小）。
- 因此，计算出的新容量可能会被向上调整到最近的内存对齐边界。

示例：
```go
slice := make([]int32, 0, 3)  // int32 占 4 字节
for i := 0; i < 5; i++ {
    slice = append(slice, int32(i))
    fmt.Println("len:", len(slice), "cap:", cap(slice))
}
```
输出可能为：
```
len: 1 cap: 3
len: 2 cap: 3
len: 3 cap: 3
len: 4 cap: 6   // 翻倍到 6
len: 5 cap: 6
```
新容量 6 是对齐后的结果，可能因平台而异。

---

### 3. **元素大小对扩容的影响**
扩容策略还会考虑切片元素的大小，因为大元素类型的切片占用更多内存，频繁翻倍可能导致内存浪费。

- **小元素类型（如 `int`, `byte`）**：容量增长更倾向于翻倍或接近 1.25 倍。
- **大元素类型（如结构体）**：增长更保守，避免一次性分配过多内存。

示例（大元素类型）：
```go
type BigStruct struct {
    data [100]int
}
slice := make([]BigStruct, 0, 100)
slice = append(slice, BigStruct{})
fmt.Println(len(slice), cap(slice))  // 1, 100
slice = append(slice, BigStruct{})
// 新容量可能为 125 或 128（视内存对齐而定），而不是 200
```

---

### 4. **源码中的实现细节**
Go 的扩容逻辑在 `runtime` 包的 `growslice` 函数中实现。主要步骤：
1. **检查溢出**：确保新长度不会超过 `math.MaxInt`。
2. **计算新容量**：
   - 如果 `oldCap < 256`，则 `newCap = oldCap * 2`。
   - 如果 `oldCap >= 256`，则逐步增加容量，公式近似为 `newCap = oldCap + (oldCap + 3*elemSize) / 4`，并调整到内存对齐边界。
3. **分配内存**：调用 `mallocgc` 分配新数组。
4. **复制数据**：使用 `memmove` 将旧数据迁移到新数组。
5. **返回新切片**：构造新的切片结构体。

---

### 5. **性能优化与注意事项**
- **预分配容量**：如果能预估切片的大小，使用 `make([]T, 0, estimatedCap)` 初始化可以减少扩容次数，提高性能。
  ```go
  slice := make([]int, 0, 1000)
  for i := 0; i < 1000; i++ {
      slice = append(slice, i)  // 无需扩容
  }
  ```
- **频繁扩容的代价**：每次扩容涉及内存分配和数据复制，时间复杂度为 O(n)。避免在循环中频繁触发扩容。
- **共享底层数组的影响**：扩容后，新切片与旧切片不再共享底层数组，旧切片仍指向旧数组。

示例：
```go
s1 := make([]int, 2, 2)
s1[0], s1[1] = 1, 2
s2 := s1
s1 = append(s1, 3)  // 扩容，s1 指向新数组
s2[0] = 10          // 修改 s2，不影响 s1
fmt.Println(s1)     // [1, 2, 3]
fmt.Println(s2)     // [10, 2]
```

---

### 6. **总结**
Go 的切片扩容策略是一个平衡性能与内存使用的设计：
- **小规模时**：快速翻倍增长，适应动态需求。
- **大规模时**：渐进增长（约 1.25 倍），避免内存浪费。
- **内存对齐**：确保分配效率。
- **元素大小**：根据类型调整策略。

通过理解这些细节，你可以在使用切片时优化代码，例如预分配容量以减少扩容开销，或者在特定场景下选择合适的初始容量。如果你有更具体的扩容场景或问题，欢迎进一步讨论！