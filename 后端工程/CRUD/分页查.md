# 📌 分页查询 

## 📄 罗列场景

🔖 用户操作日志查询系统

**业务场景：**

- 目标用户：系统管理员或安全审计人员。
- 功能需求：允许用户查询系统内所有用户的操作记录，包括登录、登出、修改密码等。支持按时间范围、用户名筛选并进行分页展示。

**关键特性：**

- 维护变化性：低，字段和逻辑稳定。
- 数据量：中到大，取决于系统的使用频率和年限。
- 一致性要求：低，可以接受几秒内的延迟。

---

🔖 电商平台商品搜索

**业务场景：**

- 目标用户：普通消费者。
- 功能需求：提供商品搜索服务，支持按关键词、价格区间、品牌、评分等多种条件过滤，并支持分页显示搜索结果。

**关键特性：**

- 简明通用：中，虽然“商品搜索”很普遍，但具体实现细节差异较大。
- 维护变化性：高，随着市场策略调整，排序规则和过滤条件可能频繁变动。
- 数据量：非常大，特别是对于大型电商平台而言。
- 一致性要求：中低，用户对最新的商品上架信息有一定的容忍度。

---

🔖 **金融交易系统的对账明细查询**

**业务背景**

- 目标用户：财务部门员工。
- 功能需求：提供每日/每月交易流水查询服务，确保每一笔交易都被准确记录，并能够按账户、日期范围等条件进行精确查找与核对。

**关键特性**

- 维护变化性：极低，一旦上线后改动较少。
- 数据量：极大，长期积累的数据量庞大。
- 一致性要求：极高，不允许有任何错误或遗漏。

----

🔖 社交应用的消息会话列表

**业务背景**

- 目标用户：社交软件用户。
- 功能需求：展示用户的所有聊天会话，按照最近一次消息的时间降序排列，支持加载更多历史消息。

**关键特性**

- 维护变化性：中，可能会根据用户体验调整界面布局或增加新功能。
- 数据量：单用户相对较小，但总体数量可观。
- 一致性要求：中高，用户期望看到最新的消息状态。

## 📄 结构拆解

一个分页查询构成

1. 输入：

```json
{
  // where 类条件
  filter condition....
  
  // 排序条件
  sort condigtion
  
  // 分页条件
  page condition
}
```

2. 查询方式：

- limit offset
- 游码查询

3. 输出：

```json
{
  page info
  data info
}
```

## 📄 优雅入参

基于以下前提：

1. 表新增字段，查询逻辑变更时总要改大批量的代码
2. 不同的端使用端尤其最优实践，需要衡量兼顾

🔖 排序条件输入

---

**前端：用户交互层**

```json
{
  sorts: [{
    targetName: "",
    sortType: ""
  }]
}
```

----

**后端：逻辑处理层**

1. 识别目标字段 + 排序方式
2. 基本合法性、安全性校验
3. 构造 SQL

----

**DB：数据管理层**

执行 SQL：

```Mysql
Select * from target_table where ...
order by 
targetName_ sortType_,
...
...
```

${\large {\color[RGB]{250, 157, 30}分类点}} $

1. **targetName = targetName_，即输入字段名和表中字段名严格对应**

**优点：**

- 不需要做映射。逻辑处理层的目标字段识别工作的复杂度较低

- 后续大量增加字段字段枚举类维护即可，不需要修改代码逻辑。
- 自明性

**缺点：**

- 表变迁修改字段，需要引入代码映射逻辑，自明性破坏且造成误解

---

2. **对输入 targetName 做码值抽象**

**优点：**

- 架构稳定，可以适应结构变迁

**缺点：**

- 多做一层映射

---

3. sortType的定义域为 ASC、DESC

- ASC、DESC两个值类型有限，也已经作为成为经典的排序方式表达的词组。其表达能力和其它形式的同等或更优。因此直接传这两个即可

## 📄 效率分析

分页查询效率瓶颈分析以及优化：
[limit offset.md](../../数据存储/MySQL/limit offset.md) 



## 📄 分页代码实现

本质上，分页查使用了 limit 语法。
针对 mybatis 下的 Mysql 开发情形，有几种方式：

### 🔖 xml 实现

直接在 xml 编写语句分页以及求 total

### 🔖 pageHelper

> `PageHelper` 是一个为 **MyBatis** 框架设计的开源分页插件，由国内开发者 **abel533（GitHub ID）** 于 2014 年左右发起并维护。它因其**简单易用、无侵入性、支持多数据库**等优点，在中国 Java 后端开发社区中迅速流行，成为 MyBatis 生态中最广泛使用的分页解决方案之一。

**核心机制**

1. ThreadLocal 边界：`PageHelper.startPage(pageNum, pageSize)`
   把分页参数放入当前线程上下文，只对“紧随其后的那一次”查询生效；执行完会清理上下文
2. 双查询模式：默认执行两条 SQL：
   - select count(*) 包裹元 SQL
   - 带 limit / offset的数据查询

**优缺点 OR 坑**

- 注意发生时机。
- 与执行 SQL 严格绑定。以后删一起删、增避免在两者中间增加
- count 会默认执行，必要时非关闭。
- 只在当前线程有效（存储与 ThreadLocal）

**代码示例：**

```java
// 经典用法
PageHelper.startPage(pageNum, pageSize);
List<Entity> list = mapper.selectByCond(cond);
PageInfo<Entity> page = new PageInfo<>(list);  // 封装总数、总页数等
// 边界安全用法（推荐）
PageInfo<Entity> page = PageHelper
    .startPage(pageNum, pageSize)
    .doSelectPageInfo(() -> mapper.selectByCond(cond));
```

----

### 🔖 MyBatis-Plus 内置分页

Mybatis plus 也提供了分页方式

**基本原理：**

> 物理分页拦截器在执行查询时自动改写 SQL，追加 LIMIT/OFFSET，并可选执行一次 COUNT(*) 统计总数；返回 Page/IPage，包含当前页数据和统计信息

**使用方式**

配置

1. 引入 Mybatis-plus

2. 在 MybatisPlus 配置 Bean 中引入拦截器

```java
/**
 * @author Axel.Xun
 * @date 2026/01/08/14:32
 */
@Configuration
public class MyBatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

---

执行

```java
// ... build queryWrapper 构造 queryWrapper
Page<MusicTag> result =  mapper.selectPage(new Page<>(request.getPageIndex(), request.getPageSize()), queryWrapper);
dto.builder()
  .data(result.getRecords())
  .pageIndex((int)result.getCurrent())
  .pageSize((int)result.getSize())
  .total((int)result.getTotal())
  .build();
Page<?> p = new Page<>(current, size, false);` 或 `p.setSearchCount(false); // 关闭统计：（不执行 COUNT 提升性能）

```

**优点**

- 统计Count 的 SQL 做了优化，会将 OrderBy 等语句做优化
- 方言级分页改写（按照 DBType）生成各库原声分页语法 `（MySQL LIMIT / OFFSET、PG OFFSET/FETCH、Oracle ROWNUM、SQL SERVER OFFSET/FETCH）`
- ......

### 🔖 测评比较

From AI

![image-20251225114304229](https://raw.githubusercontent.com/ChenXuRiYue/image-cloud/main/global/image-20251225114304229.png)

## 🌳 生长思考

对发散的自由捕捉、精确化

## 💭 反复绊脚

记录回顾、使用文档时，遇到的困惑



## 🗺️ 修订记录

重要修订记录

## 🛠️ 实践经历

记录实践经历： demo + 工作经历 + 第三方优秀经验反思



## ⚙️ prompt

探究该文档模块过程中的 prompt 记录
模版如下：

```markdown
# 背景
我是一名追求效率的学习者。我从事于Java后端开发工程师的工作。
我认为学习本质上就是 大量正确信息的消化 + 关键结论的感受 + 自由的发散。
依托这样的思想，我希望和你来进行一场talk。

我们的 talk 基于以下原则
1. 你是 该talk 主题下的专家
2. 我是一名在其他领域具有通用性技能的工程师，如 Java、传统算法、后端工程、C++ 语法、Go 语法等。拥有一定计算机基础的知识。
3. 我们是不同领域的擅长者，这是一场圆桌会议式的talk。就和索尔维会议一样，阿尔伯特·爱因斯坦与尼尔斯·玻尔之间的交流。
4. 以你的权重为主前提下，我希望我们相互的问询感兴趣的内容。这样可以推动 talk 的进度。
# talk 主题
我在研究探讨怎么完成 Java Spring 项目下各种场景的优雅分页查询

# 思维链
1. 我对信息的要求是，你应该减少幻觉，即信息是足够正确的
2. 我总是对一件事物的是什么、从哪里来感到好奇。所以，你可以简略说明它的历史阶段以及发展哲学
3. 我一边和你 talk，一边做草稿笔记。因此你的言语足够开阔，具有阐述性的同时，也要让我容易从中记录归纳总结。但是请你不要直接给我总结笔记，因为我希望可以主动消化。

# 输入格式
我将会输入一个问题

# 输出格式
不需要特殊的模版。参照思维链
# 当前问题
目前我需要学习 Spring 框架下的几种常见分页实现。
1. pageHelper 实现方式

# 问题阶段(记录了 talk 的过程，方便复用)


--------
以下内容是我方便复制粘贴模版，请你忽略
## 问题X：
### 问题描述：

### 关键结论：
```



