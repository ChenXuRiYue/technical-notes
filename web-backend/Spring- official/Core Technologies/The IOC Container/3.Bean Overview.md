# 📖Bean Overview

${\large {\color[RGB]{250, 157, 30}概述}} $

一个 Spring Ioc 容器管理一个或者多个 Bean。Bean 是通过提供给容器的配置元数据创建的。

${\large {\color[RGB]{250, 157, 30}Bean \ 结构}} $

在容器本身，这些 Bean 被定义为 BeanDefinition 对象，它包含了以下元数据

1. 一个**全路径类**名：通常，被定义的Bean的实际实现类
2. Bean的**行为配置元素**，它说明了Bean在容器中的行为方式（scope、生命周期回调，等等）
3. **对其他Bean的引用**，这些Bean需要做它的工作。这些引用也被称为合作者或依赖
    [💭 xml 配置Bean方式下，是否需要要描述 Bean 依赖关系？](#💭 xml 配置Bean方式下，是否需要要描述 Bean 依赖关系？)
4. 要在新创建的对象中设置的其他配置设置—例如，pool的大小限制或在管理连接池的Bean中使用的连接数

${\normalsize{\color[RGB]{253, 175, 14}属性列表}}$
| 属性                     | 解释…                                                        |
| :----------------------- | :----------------------------------------------------------- |
| Class                    | [实例化 Bean](https://springdoc.cn/spring/core.html#beans-factory-class) |
| Name                     | [Bean 命名](https://springdoc.cn/spring/core.html#beans-beanname) |
| Scope                    | [Bean Scope](https://springdoc.cn/spring/core.html#beans-factory-scopes) |
| Constructor arguments    | [依赖注入](https://springdoc.cn/spring/core.html#beans-factory-collaborators) |
| Properties               | [依赖注入](https://springdoc.cn/spring/core.html#beans-factory-collaborators) |
| Autowiring mode          | [注入协作者（Autowiring Collaborators）](https://springdoc.cn/spring/core.html#beans-factory-autowire) |
| Lazy initialization mode | [懒加载的Bean](https://springdoc.cn/spring/core.html#beans-factory-lazy-init) |
| Initialization method    | [初始化回调](https://springdoc.cn/spring/core.html#beans-factory-lifecycle-initializingbean) |
| Destruction method       | [销毁回调](https://springdoc.cn/spring/core.html#beans-factory-lifecycle-disposablebean) |

## 📖 Bean 别名

${\large {\color[RGB]{250, 157, 30}Bean 别名}} $

每个Bean都有一个或多个标识符（identifier）。这些标识符在承载Bean的容器中必须是唯一的。一个Bean通常只有一个标识符。然而，如果它需要一个以上的标识符，多余的标识符可以被视为别名。

${\normalsize{\color[RGB]{253, 175, 14}XML \ 中配置}}$
**命名规范：**小写字母开头，驼峰法
**默认命名：**取简单的类名并将其初始字符变成小写。然而，在（不寻常的）特殊情况下，当有一个以上的字符，并且第一个和第二个字符都是大写时，原来的大小写会被保留下来

${\large {\color[RGB]{250, 157, 30}在 Bean Definition 之外对Bean进行别名}}$
XML 中通过 \<alias> 标签

${\large {\color[RGB]{250, 157, 30}Java 配置}} $
详看 $Bean$ 等注解使用

### 📖 实例化 Bean

- 通常，在容器本身通过反射式地调用构造函数直接创建Bean的情况下，指定要构造的Bean类，有点相当于Java代码中的 `new` 操作符。
- 在不太常见的情况下，即容器在一个类上调用 `static` 工厂方法来创建 bean 时，要指定包含被调用的 `static` 工厂方法的实际类。从 `static` 工厂方法的调用中返回的对象类型可能是同一个类或完全是另一个类。

${\large {\color[RGB]{250, 157, 30}Bean 使用构造函数进行初始化}} $

> 当你用构造函数的方法创建一个Bean时，所有普通的类都可以被Spring使用并与之兼容。也就是说，被开发的类不需要实现任何特定的接口，也不需要以特定的方式进行编码。只需指定Bean类就足够了。然而，根据你对该特定Bean使用的IoC类型，你可能需要一个默认（空）构造函数。

解读：不需要强制 bean 实现任何接口。

存在多种 IOC（控制反转的类型），一些控制类型是需要 setter 方法实例化的。这要求Bean 类实现默认构造函数。先创建后初始化。

例如以下配置是通过 setter 注入：
```xml
<bean id="userService" class="com.example.UserService">
    <property name="name" value="Alice"/>
</bean>
```

${\normalsize {\color[RGB]{250, 157, 30}几种IOC 类型}} $

| 方式                       | 说明                                       |
| -------------------------- | ------------------------------------------ |
| 1. 基于 XML 的 setter 注入 | 使用 `<property>`，通过 setter 方法注入    |
| 2. 基于 XML 的构造函数注入 | 使用 `<constructor-arg>`，通过构造函数注入 |
| 3. 基于注解的自动装配      | 使用 `@Autowired`、`@Value` 等             |
| 4. 基于 Java Config        | 使用 `@Configuration` + `@Bean` 方法       |
| 5. 组件扫描 + 构造函数注入 | `@Component` + 构造函数参数自动注入        |

${\large {\color[RGB]{250, 157, 30}Bean 用静态工厂方法进行实例化}} $

Spring 中提供了实用静态工厂方法进行实例化的方式。一般有以下用途：

1. 在历史遗留代码中调用 static 工厂。

示例：

```xml
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
```

```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```

${\large {\color[RGB]{250, 157, 30}Bean 用实例工厂方法进行实例化}} $

Spring 提供了用实例工厂方法进行的实例化从容器中调用现有 bean 的非静态方法来创建一个新的 bean。使用这种机制应该先将 class 属性留空，，并在 `factory-bean` 属性中指定当前（或父代或祖代）容器中的一个 Bean 的名称，该容器包含要被调用来创建对象的实例方法。用 `factory-method` 属性设置工厂方法本身的名称。



Xml 配置
```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

```

Bean 类：

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}


```

工厂类：

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
```

${\large {\color[RGB]{250, 157, 30}确定 Bean 的运行时类型}} $

由于注入方式中工厂方法模式创建bean。以及AOP代理技术下需要创建代理对象。Bean 的类型确定是困难的。

对于开发来说：推荐使用 BeanFactory.getType 调用。

```java
String beanName = "userService";
Class<?> beanType = applicationContext.getType(beanName);
System.out.println("The actual runtime type of '" + beanName + "' is: " + beanType.getName());
```

${\normalsize {\color[RGB]{250, 157, 30}getType 方法实现}} $

1. 尝试从 ConcurrentHashMap<String, Class<?>> typeCache 中读取出类型。
2. 现场计算：多种分类讨论。（细节后续看源码 ==TODO==）

## 🌳 发散

#### 💭 xml 配置Bean方式下，是否需要要描述 Bean 依赖关系？

📄 绝大多数情况下需要手动在 XML 中显示的生命依赖关系。

**Service**

```java
public class UserService {
    private UserDAO userDAO;
    
    // setter 方法
    public void setUserDAO(UserDAO userDAO) {
        this.userDAO = userDAO;
    }
}
```

**Dao**

```java
public class UserDAO {
    // 数据访问逻辑
}
```

**XML**

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 定义 UserDAO Bean -->
    <bean id="userDAO" class="com.example.UserDAO" />

    <!-- 定义 UserService Bean，并手动注入 userDAO -->
    <bean id="userService" class="com.example.UserService">
       <property name="userDAO" ref="userDAO" />
    </bean>

</beans>
```

如上，需要通过`<property name="userDAO" ref="userDAO" />` 完成依赖关系的配置。

在这里猜测 XML 被淘汰的主要原因之一就是需要重新描述一遍依赖关系。
