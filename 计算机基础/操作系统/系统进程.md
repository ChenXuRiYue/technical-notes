### **一、进程的定义**

**进程**是**程序的一次执行过程**，是操作系统资源分配和调度的**基本单位**。

- 程序是静态的代码文件（如.exe），进程是动态的执行实例（如运行中的计算器程序）。

- 每个进程包含独立的**地址空间、代码段、数据段、打开的文件句柄、CPU 状态**等资源。

### **二、进程的三大核心状态**

#### **1. 运行态（Running）**

- 进程正在 CPU 上执行。

- **同一时刻单 CPU 系统中只有一个进程处于运行态**。

#### **2. 就绪态（Ready）**

- 进程已具备执行条件，但因 CPU 资源不足而等待调度。

- 多个就绪态进程组成**就绪队列**，等待操作系统分配 CPU。

#### **3. 阻塞态（Blocked）**

- 进程因等待某事件（如 I/O 完成、信号量资源）而暂停执行，无法被调度。

- 事件完成后，进程从阻塞态转为就绪态。

**状态转换图**：

```
          +------+     时间片用完     +------+
          |运行态|------------------>|就绪态|
          +------+     等待事件       +------+
             ^       (如I/O完成)       |
             |                         v
             +------<------------------+阻塞态|
                     事件完成
```

### **三、进程与线程的区别**

| **维度**            | **进程**                           | **线程**                           |
| ------------------- | ---------------------------------- | ---------------------------------- |
| **定义**            | 资源分配的基本单位                 | CPU 调度的基本单位（轻量级进程）   |
| **地址空间**        | 独立地址空间（互不干扰）           | 共享进程的地址空间                 |
| **创建 / 销毁开销** | 高（需分配内存、文件句柄等）       | 低（仅需保存寄存器状态）           |
| **通信方式**        | 需通过 IPC（如管道、消息队列）     | 直接共享变量                       |
| **典型场景**        | 多任务独立程序（如浏览器、编辑器） | 单程序内多任务（如浏览器多标签页） |

### **四、进程调度（CPU 调度）**

#### **1. 调度目标**

- 公平性：避免某些进程长期饥饿（Starvation）。

- 高效性：提升 CPU 利用率，减少上下文切换（Context Switch）开销。

#### **2. 常见调度算法**

1. **先来先服务（FCFS）**

- 按进程就绪顺序调度，先进入就绪队列的先执行。

- **优点**：实现简单；**缺点**：对短进程不友好（可能长期等待）。

1. **短作业优先（SJF）**

- 优先调度预计执行时间最短的进程。

- **优点**：平均等待时间短；**缺点**：需预知作业执行时间（实际难实现）。

1. **时间片轮转（RR）**

- 将 CPU 时间划分为固定时间片（如 10ms），就绪队列中进程轮流运行一个时间片。

- **优点**：响应快，适合交互式系统（如桌面 OS）；**缺点**：时间片过短会增加切换开销。

1. **优先级调度**

- 为每个进程分配优先级，优先调度高优先级进程。

- **分类**：

- **非抢占式**：运行进程主动放弃 CPU 才切换。

- **抢占式**：高优先级进程可中断低优先级进程（如实时系统）。

### **五、进程同步与互斥**

#### **1. 临界资源与临界区**

- **临界资源**：同一时刻只能被一个进程访问的资源（如打印机、共享变量）。

- **临界区**：进程中访问临界资源的代码段。

#### **2. 互斥机制**

- **信号量（Semaphore）**

- 由 Dijkstra 提出的整数变量，用于控制对临界资源的访问。

- **PV 操作**：

- **P 操作（Wait）**：申请资源，信号量减 1；若小于 0 则阻塞。

- **V 操作（Signal）**：释放资源，信号量加 1；若小于等于 0 则唤醒阻塞进程。

- **示例**：用信号量实现两个进程互斥访问打印机：

```
semaphore mutex = 1;  // 初值为1（表示可用资源数）

process A:           process B:
P(mutex);           P(mutex);
访问打印机;         访问打印机;
V(mutex);           V(mutex);
```

- **互斥锁（Mutex Lock）**

- 更轻量级的互斥工具，加锁后其他进程无法进入临界区，适合短临界区。

### **六、进程间通信（IPC，Inter-Process Communication）**

#### **1. 管道（Pipe）**

- **匿名管道**：单向通信，仅用于父子进程间（如 Linux 的pipe()函数）。

- **命名管道（FIFO）**：可在非亲缘进程间通信，以文件形式存在（如 Linux 的mkfifo）。

#### **2. 消息队列（Message Queue）**

- 进程间通过发送 / 接收结构化消息（如消息类型 + 数据）通信，克服了管道的字节流限制。

#### **3. 共享内存（Shared Memory）**

- 多个进程映射同一块物理内存区域，直接读写共享数据，是最快的 IPC 方式（需配合信号量实现同步）。

#### **4. 套接字（Socket）**

- 用于跨网络或跨主机的进程通信，支持 TCP/UDP 协议（如网络聊天程序）。

### **七、进程控制块（PCB，Process Control Block）**

- **定义**：操作系统用于管理进程的核心数据结构，存储进程的所有状态信息，如：

- 进程 ID（PID）、优先级、状态（运行 / 就绪 / 阻塞）。

- 程序计数器（PC，指向下一条指令地址）。

- 内存指针（指向进程地址空间）、打开文件列表等。

- **作用**：PCB 是进程存在的唯一标识，操作系统通过 PCB 完成进程调度、上下文切换等操作。

### **八、总结**

- **核心本质**：进程是操作系统对 “程序执行” 的抽象，通过调度、同步、通信等机制实现多任务管理。

- **关键问题**：

- 如何高效分配 CPU 资源（调度算法）？

- 如何避免临界资源竞争（互斥机制）？

- 如何实现进程间数据交换（IPC 技术）？

如需补充具体操作系统（如 Linux/Windows）的进程实现细节，或深入探讨某一机制（如僵尸进程处理），可随时说明！